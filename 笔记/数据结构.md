# 数据结构



#### 数据结构 = 结构定义 + 结构操作

数据结构：线性结构：数据元素之间存在一对一关系（链表、队列、栈）

　　　　　非线性结构：集合结构：数据元素属于同一个集合

　　　　　　　　　　　树型结构：数据元素之间存在一对多关系（二叉树、二叉查找树、平衡二叉查找树）

　　　　　　　　　　　图形结构：数据元素之间存在多对多关系

　　　　　顺序存储结构：数据元素在存储器中连续存储

　　　　　　　　　　　　可以用相对位置来表示数据元素之间的逻辑结构（顺序表、队列、栈）

　　　　　链式存储结构：每个数据元素里设置了一个指针用来指向另一个元素的存储地址

时间复杂度：按效率从高到低排列

### 线性表

线性表是有相同数据类型的n个数据元素组成的有限序列

L = (a0, a1, a2, ..., an-1)

a0是唯一的第一个数据元素，表头元素

an-1是唯一的最后一个数据元素，表尾元素

线性表中的元素具有逻辑上的顺序性

#### 顺序表

线性表是逻辑结构，表示元素之间一对一的相邻关系，而顺序表是存储结构，是指用一组地址连续的存储单元，依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。

特点：可以进行随机访问（可以通过表头元素的地址和元素的编号（下标）在O(1)的时间复杂度内找到指定的元素。

> 设顺序表的第一个元素a0的存储地址为Loc(a0)，每个元素占d个存储空间
>
> 则第i个元素的地址为：Loc(ai-1) = Loc(a0) + (i - 1) ×d

函数：

1. **insert(loc, value)：**将value插入到顺序表中下标为loc的位置，O(n)

   　　　　　　　　插入操作：判断插入位置是否合法

   　　　　　　　　　　　　　判断顺序表是否已满

   　　　　　　　　　　　　　将目标位置及之后的元素后移一位

   　　　　　　　　　　　　　将待插入的元素值插入到目标位置

2. **expand()：**扩大顺序表的容量，扩大二倍，O(n)

   ​                   扩容操作：将原来的元素存储到临时存储空间

   　　　　　　　　　　扩大原来的存储空间

   　　　　　　　　　　将临时存储空间里的数据元素复制到新的存储空间里

   　　　　　　　　　　释放临时存储空间

3. **search(value)：**寻找顺序表中值为value的元素，O(n)

​                                   查找操作：从下标为０的元素开始依次枚举顺序表中的所有元素

　　　　　　　　　　　　　　发现和目标值相等的元素则返回它的下标

　　　　　　　　　　　　　　枚举结束没有找到目标元素则返回-1

4. **remove(index)：**将顺序表中下标为index的元素移除，O(n)

​                                     删除操作：判断传入的参数是否合法，即下标是否在顺序表的范围内

　　　　　　　　　　　　　　　将目标下标之后所有的元素前移一位

　　　　　　　　　　　　　　　更新顺序表的长度

5. **print()：**输出顺序表中所有的元素，O(n)

　　　　　　遍历操作：从下标为0的元素开始遍历顺序表

　　　　　　　　　　　输出所有元素的值

> 顺序表的构造、插入、扩容、查找、删除、遍历

```c
#include <stdio.h>
#include <stdlib.h>

#define ERROR 0
#define OK 1

typedef struct Vector {
    int size, length;      //size当前最大容量，length元素个数
    int *data;      //指向存储元素的数组
} Vector;

void init(Vector *vector, int size) {       //构造一个容量为size的顺序表
    vector->size = size;
    vector->length = 0;
    vector->data = (int *)malloc(sizeof(int) * size);   //让date指向一段连续size个int的空间
}

// 扩容函数 expand
void expand(Vector *vector) {
    int *old_data = vector->data;
    vector->size = vector->size * 2;
    vector->data = (int *)malloc(sizeof(int) * vector->size);
    for (int i = 0; i < vector->length; i++) {
        vector->data[i] = old_data[i];
    }
    free(old_data);
}

int insert(Vector *vector, int loc, int value) {     //vector要插入元素的顺序表，loc要插入的位置，value插入的元素值
    if (loc < 0 || loc > vector->length) {
        return ERROR;
    }
    if (vector->length >= vector->size) {      //判断顺序表当前元素个数是否已经达到容量上限
        //return ERROR;
        expand(vector);
    }
    for (int i = vector->length; i > loc; i--) {     //将loc之后的所有元素顺次向后移动
        vector->data[i] = vector->data[i - 1];
    }
    vector->data[loc] = value;
    vector->length++;
    return OK;
}

int search(Vector *vector, int value) {
    for (int i = 0; i < vector->length; i++) {
        if (vector->data[i] == value) {
            return i;
        } 
    }
    return -1;
}

int delete_node(Vector *vector, int index) {
    if (index < 0 || index >= vector->length) {
        return ERROR;
    }
    for (int i = index + 1; i < vector->length; ++i) {
        vector->data[i - 1] = vector->data[i];
    }
    vector->length--;
    return OK;
}

void print(Vector *vector) {
    for (int i = 0; i < vector->length; i++) {
        if (i > 0) {
            printf(" ");
        }
        printf("%d", vector->data[i]);
    }
    printf("\n");
}

void clear(Vector *vector) {      //释放占用的内存空间
    free(vector->data);
    free(vector);
}

int main() {
    Vector *a = (Vector *)malloc(sizeof(Vector));
    init(a, 100);
    printf("%d\n", insert(a, 1, 0));
    printf("%d\n", insert(a, 0, 1));
    printf("%d\n", insert(a, 2, 1));
    printf("%d\n", insert(a, 1, 2));
    printf("%d\n", insert(a, 0, 3));
    clear(a);
    return 0;
}
```

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define DEFAULT_ARG(a, b) ((#a)[0] ? a + 0 : b)
#define init(a) __init(DEFAULT_ARG(a, 10))     //设置init默认值为10

typedef struct Vector {
    int *data;
    int size, length;
} Vector;

Vector *__init(int n) {
    Vector *p = (Vector *)malloc(sizeof(Vector));
    p->data = (int *)malloc(sizeof(int) * n);
    p->size = n;
    p->length = 0;
    return p;
}

int expand(Vector *v) {
    printf("[%p] expanding\n", v->data);
    int *p = (int *)realloc(v->data, sizeof(int) * 2 * v->size);
    if ( p == NULL) return 0;
    v->data = p;
    v->size *= 2;
    printf("[%p] expand vector success, the new size : %d\n", v->data, v->size);
    return 1;
}

int insert(Vector *v, int value, int ind) {
    if (v->length == v->size) {
        if (expand(v) == 0) {
            return 0;
        }
    }
    if (ind < 0 || ind > v->length) return 0;
    for (int i = v->length - 1; i >= ind; --i) {
        v->data [i + 1] = v->data[i];
    }
    v->data[ind] = value;
    v->length += 1;
    return 1;
}

int erase(Vector *v, int ind) {
    if (v->length == 0) return 0;
    if (ind < 0 || ind > v->length) return 0;
    for (int i = ind + 1; i < v->length; i++) {
        v->data[i - 1] = v->data[i]; 
    }
    v->length -= 1;
    return 1;
}

void clear(Vector *v) {
    if (v == NULL) return ;
    free(v->data);
    free(v);
    return ;
}

void output(Vector *v) {
    printf("Vector = [");
    for (int i = 0; i < v->length; i++) {
        printf(" %d", v->data[i]);
    }
    printf("]\n");
    return ;
}

int main() {
    Vector *v = init();
    #define MAX_OP 40 
    for (int t = 0; t < MAX_OP; t++) {
        int op = rand() % 5, ind, value;
        switch (op) {
            case 2 :
            case 3 :
            case 4 :
            case 0 : {
                ind = rand() % (v->length + 3) - 1;
                value = rand() % 100;
                printf("[%d] insert(%d, %d) to vector\n", insert(v, value, ind), value, ind);
                output(v);
            } break;
            case 1 : {
                ind = rand() % (v->length + 3) - 1;
                printf("[%d] erase(%d) from vector\n", erase(v, ind), ind);
                output(v);
            } break;
        }
    }
    clear(v);
    return 0;
}
```

> 输入格式：第一行输入一个正整数m，代表一共有m个操作，接下来输入m行，每行首先输入一个整数t：
>
> 1. t = 1，插入操作，输入两个整数a和b，表示在a的位置上插入b，插入成功：success，否则：failed
> 2. t = 2，删除操作，输入一个整数a，删除位置a上的元素，删除成功：success，否则：failed
> 3. t = 3，查找操作，输入一个整数a，查找元素值为a的元素，查找成功：success，否则：failed
> 4. t = 4，遍历操作，输出当前顺序表的所有元素，从下标为0的位置开始输出当前顺序表的所有元素，每两个整数之间一个空格，最后一个整数后面没有空格。

```c
#include <stdio.h>
#include <stdlib.h>

#define ERROR 0
#define OK 1

typedef struct Vector {
	int size, length;
    int *data;
} Vector;

void init(Vector *vector, int size) {
	vector->size = size;
    vector->length = 0;
    vector->data = (int *)malloc(sizeof(int) * size);
}

void expand(Vector *vector) {
	int *old_data = vector->data;
    vector->size = vector->size * 2;
    vector->data = (int *)malloc(sizeof(int) * vector->size);
    for (int i = 0; i < vector->length; i++) {
        vector->data[i] = old_data[i];
    }
    free(old_data);
}

int insert(Vector *vector, int loc, int value) {
	if (loc < 0 || loc > vector->length) {
        return ERROR;
    }
    if (vector->length >= vector->size) {
        expand(vector);
    }
    for (int i = vector->length; i > loc; i--) {
        vector->data[i] = vector->data[i - 1];
    }
    vector->data[loc] = value;
    vector->length++;
    return OK;
}

int search(Vector *vector, int value) {
    for (int i = 0; i < vector->length; i++) {
        if (vector->data[i] == value) {
            return i;
        }
    }
    return -1;
}

int delete_node(Vector *vector, int index) {
	if (index < 0 || index > vector->length) {
        return ERROR;
    }
    for (int i = index + 1; i < vector->length; i++) {
        vector->data[i - 1] = vector->data[i];
    }
    vector->length--;
    return OK;
}

void print(Vector *vector) {
	for (int i = 0; i < vector->length; i++) {
        if (i > 0) {
            printf(" ");
        }
        printf("%d", vector->data[i]);
    }
    printf("\n");
}

void clear(Vector *vector) {
	free(vector->data);
    free(vector);
}

int main() {
    Vector *a = (Vector *)malloc(sizeof(Vector));
    init(a, 20);
	int m, t, loc, value;
    scanf("%d", &m);
    for (int i = 0; i < m; i++) {
        scanf("%d", &t);
        if (t == 1) {
            scanf("%d %d", &loc, &value);
            printf("%s\n", insert(a, loc, value) == OK ? "success" : "failed");
        } else if (t == 2) {
            scanf("%d", &loc);
            printf("%s\n", delete_node(a, loc) == OK ? "success" : "failed");
        } else if (t == 3) {
            scanf("%d", &value);
            printf("%s\n", search(a, value) == -1 ? "failed" : "success");
        } else {
            print(a);
        }
    }
    return 0;
}
```

#### 链表

一般链表中只有一个表头

特点：元素之间前后依赖，串联而成；链表的元素不能随机访问；元素前面和后面不会出现多个元素相连的情况

链表的结点由数据域和指针域组成

函数：

1. **insert(node, index) ：**将node插入到下标为index的位置，O(n)

　　　　　　　　　　　　插入操作：找到链表中要插入的位置

　　　　　　　　　　　　　　　　　令待插入结点的next指针指向插入位置的当前结点

　　　　　　　　　　　　　　　　　令插入位置之前的当前结点的next指针指向待插入结点

2. **output()：**输出整个链表，O(n)

   　　　　　遍历操作：定义一个用于遍历的变量，初始指向头结点

   　　　　　　　　　　输出遍历变量所在结点的值，并更新遍历变量为当前结点的下一个结点

   　　　　　　　　　　重复操作，直至遍历完所有结点

3. **delete_node(index)：**将链表中下标为index的元素删除，O(n)

   ​                                      删除操作：从表头遍历找到要删除的位置

   　　　　　　　　　　　　　　　令删除位置前一个结点的next指针指向待删除位置后一个结点

   　　　　　　　　　　　　　　　删除结点

4. **reverse()：**翻转整个链表，O(n)

   　　　　　翻转操作：定义一个用于遍历的指针，初始指向头结点后一个结点

   　　　　　　　　　　让头结点的next指针置空

   　　　　　　　　　　从当前遍历指针所指的结点开始遍历链表，将遍历到的结点next指针指向头结点，遍历过程中借助另外一个指针保存下一个遍历到的结点

   　　　　　　　　　　重复步骤直至表尾，此时新的链表就是原链表翻转后的链表

> 链表的创建、插入、遍历

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct Node {
    int data;　　　　//记录每个结点的数据域
    struct Node *next;　　　　//指向下一个结点
}Node, *LinkedList;

LinkedList insert(LinkedList head, Node *node, int index) {　　　//head要插入结点的链表的头结点，index表示插入结点后这个结点是第index个结点
    if (head == NULL) {　　　　//头指针为空指针，即链表为空，当且仅当index为０时才能操作
        if (index != 0) {
            return head;
        }
        head = node;
        return head;
    }
    if (index == 0) {　　　　//插入结点后的位置是链表首位
        node->next = head;
        head = node;　　　　//表头更新
        return head;
    }
    Node *current_node = head;　　　//用于遍历链表
    int count = 0;　　　//统计遍历了多少结点
    while (current_node->next != NULL && count < index - 1) {　　//找目标位置的前一个位置
        current_node = current_node->next;
        count++;
    }
    if (count == index - 1) {
        node->next = current_node->next;
        current_node->next = node;
    }
    return head;
}

void output(LinkedList head) {
    if (head == NULL) {　　　//判断链表是否为空
        return ;
    }
    Node *current_node = head;
    while (current_node != NULL) {
        printf("%d ", current_node->data);
        current_node = current_node->next;
    }
    printf("\n");
}

LinkedList delete_node(LinkedList head, int index) {
    if (head == NULL) {
        return head;
    }
    Node *current_node = head;
    int count = 0;
    if (index == 0) {
        head = head->next;
        free(current_node);
        return head;
    }
    while (current_node->next != NULL && count < index - 1) {
        current_node = current_node->next;
        count++;
    }
    if (count == index - 1 && current_node->next != NULL) {
        Node *delete_node = current_node->next;
        current_node->next = delete_node->next;
        free(delete_node);
    }
    return head;
}

LinkedList reverse(LinkedList head) {
    if (head == NULL) {
        return head;
    }
    Node *next_node, *current_node;　　　//next_node遍历过程中下一个结点
    current_node = head->next;
    head->next = NULL;　　　　//将头结点断开
    while (current_node != NULL) {
        next_node = current_node->next;
        current_node->next = head;
        head = current_node;
        current_node = next_node;
    }
    return head;
}

void clear(LinkedList head) {　　　　//释放链表内存空间
    Node *current_node = head;
    while (current_node != NULL) {　　　　　//让current_node不断指向后一个结点来遍历整个链表来释放所有结点的内存空间
        Node *delete_node = current_node;
        current_node = current_node->next;
        free(delete_node);
    }
}

int main() {
    LinkedList linkedlist = NULL;
    for (int i = 1; i <= 10; i++) {
        Node *node = (Node *)malloc(sizeof(Node));
        node->data = i;
        node->next = NULL;
        linkedlist = insert(linkedlist, node ,i - 1);
    }
    output(linkedlist);
    linkedlist = delete_node(linkedlist, 5);
    output(linkedlist);
    linkedlist = reverse(linkedlist);
    output(linkedlist);
    clear(linkedlist);
    return 0;
}
```

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

typedef struct LinkNode {　　　//链表结点
    int data;
    struct LinkNode *next;
} LinkNode;

typedef struct Linklist {
    LinkNode head;　　　　//虚拟结点
    int length;
} Linklist;

Linklist *init() {
    Linklist *p = (Linklist *)malloc(sizeof(Linklist));
    p->head.next = NULL;
    p->length = 0;
    return p;
}

LinkNode *getNewNode(int value) {　　　//链表结点初始化
    LinkNode *p = (LinkNode *)malloc(sizeof(LinkNode));
    p->data = value;
    p->next = NULL;
    return p;
}

void insert(Linklist *l, int value, int ind) {
    LinkNode *p = &(l->head);
    while (ind--) {
        p = p->next;
        if (p == NULL) return ;
    }
    LinkNode *new_node = getNewNode(value);
    new_node->next = p->next;
    p->next = new_node;
    l->length += 1;
    return ;
}

void erase(Linklist *l,int ind) {
    LinkNode *p = &(l->head);
    while (ind--) {
        p = p->next;
        if (p == NULL) return ;
    }
    if (p->next == NULL) return ;
    LinkNode *q = p->next;
    p->next = p->next->next;
    free(q);
    l->length -= 1;
    return ;
}

void clear(Linklist *l) {
    if (l->head.next == NULL) return ;
    LinkNode *p = l->head.next, *q;
    while (p) {
        q = p;
        p = p->next;
        free(q);
    }
    free(l);
    return ;
}

void output(Linklist *l) {
    printf("[%d]", l->length);
    LinkNode *p = l->head.next;
    while (p != NULL) {
        printf("%d->", p->data);
        p = p->next;
    }
    printf("NULL\n");
    return ;
}

int main(){
    srand(time(0));
    Linklist *l = init();
    #define MAX_OP 20 
    for (int i = 0; i < MAX_OP; i++) {
        int op = rand() % 4, value, ind;
        switch (op) {
            case 0 :
            case 1 :
            case 2 : {
                ind = rand() % (l->length + 1);
                value = rand() % 100;
                printf("insert(%d, %d) to Linklist\n", value, ind);
                insert(l, value, ind);
                output(l);
            } break;
            case 3 : {
                if (l->length == 0) break;
                ind = rand() % l->length;
                printf("erase(%d) from Linklist\n", ind);
                erase(l, ind);
                output(l);
            } break;
        }
    }
    clear(l);
    return 0;
}
```

> 第一行输入一个整数m，表示一共要执行m次操作。接下来输入m行，每行首先输入一个整数t：
>
> 1. t = 1，插入操作，输入两个整数a, b，在位置a上插入值为b的元素，插入成功：success，否则：failed
> 2. t = 2，遍历操作，每个元素后面跟一个空格
> 3. t = 3，删除操作，输入一个整数a，删除位置a上的元素，删除成功：success，否则：failed
> 4. t = 4，翻转操作

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct Node{
    int data;
    struct Node *next;
}Node, *LinkedList;

LinkedList insert(LinkedList head, Node *node, int index) {
    if (head == NULL) {
        if (index != 0) {
            printf("failed\n");
            return head;
        }
        head = node;
        printf("success\n");
        return head;
    }
    if (index == 0) {
        node->next = head;
        head = node;
        printf("success\n");
        return head;
    }
    Node *current_node = head;
    int count = 0;
    while (current_node->next != NULL && count < index - 1) {
        current_node = current_node->next;
        count++;
    }
    if (count == index - 1) {
        node->next = current_node->next;
        current_node->next = node;
        printf("success\n");
        return head;
    }
    printf("failed\n");
    return head;
}

void output(LinkedList head) {
    if (head == NULL) {
        return;
    }
    Node *current_node = head;
    while (current_node != NULL) {
        printf("%d ", current_node->data);
        current_node = current_node->next;
    }
    printf("\n");
}

LinkedList delete_node(LinkedList head, int index) {
	if (head == NULL) {
        printf("failed\n");
        return head;
    }
    Node *current_node = head;
    int count = 0;
    if (index == 0) {
        head = head->next;
        free(current_node);
        printf("success\n");
        return head;
    }
    while (current_node->next != NULL && count < index - 1) {
        current_node = current_node->next;
        count++;
    }
    if (count == index - 1 && current_node->next != NULL) {
        Node *delete_node = current_node->next;
        current_node->next = delete_node->next;
        free(delete_node);
        printf("success\n");
        return head;
    }
    printf("failed\n");
    return head;
}

LinkedList reverse(LinkedList head) {
	if (head == NULL) {
        return head;
    }
    Node *next_node, *current_node;
    current_node = head->next;
    head->next = NULL;
    while (current_node != NULL) {
        next_node = current_node->next;
        current_node->next = head;
        head = current_node;
        current_node = next_node;
    }
    return head;
}

void clear(LinkedList head) {
    Node *current_node = head;
    while (current_node != NULL) {
        Node *delete_node = current_node;
        current_node = current_node->next;
        free(delete_node);
    }
}

int main() {
    LinkedList linkedlist = NULL;
	int m, t, loc, value;
    scanf("%d", &m);
    for (int i = 0; i < m; i++) {
        scanf("%d", &t);
        if (t == 1) {
            scanf("%d %d", &loc, &value);
            Node *node = (Node *)malloc(sizeof(Node));
            node->data = value;
            node->next = NULL;
            linkedlist = insert(linkedlist, node, loc);
        } else if (t == 2) {
            output(linkedlist);
        } else if (t == 3) {
            scanf("%d", &loc);
            linkedlist = delete_node(linkedlist, loc);
        } else if (t == 4) {
            linkedlist = reverse(linkedlist);
        }
    }
    clear(linkedlist);
    return 0;
}
```

**循环链表**

最后一个结点的指针指向了头结点

循环链表没有空指针，所以在判断结束条件时，不再判断指针是否为空，而是判断指针是否等于某固定指针

在单链表里，一个结点只能访问到它后面的结点，而在循环链表里它可以访问到所有的结点

**双向链表（双链表）**

单链表里的指针域只记录了结点的下一个结点，也就是后继结点，而双向链表的指针域还记录了结点的上一个结点，也就是前驱结点，这样就既可以从头结点遍历到尾结点，也可以从尾结点遍历到头结点。

**约瑟夫环**删除操作：定义一个遍历指针，初始指向head，并让head指向空地址避免操作结束后变为野指针

　　　　　　　　　找到遍历指针往后数的第n次所指向的结点

　　　　　　　　　输出该结点的数据，更新遍历指针，然后删除该结点

　　　　　　　　　重复操作直至只剩下最后一个结点

　　　　　　　　　输出最后一个结点并删除

> 创建约瑟夫环、删除环上元素

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct Node{
    int data;
    struct Node *next;
}Node, *LinkedList;

LinkedList insert(LinkedList head, Node *node, int index) {
    if (head == NULL) {
        if (index != 0) {
            return head;
        }
        head = node;
        head->next = head;   //头结点指向其本身
        return head;
    }
    if (index == 0) {
        node->next = head->next;
        head->next = node;
        return head;
    }
    Node *current_node = head->next;
    int count = 0;
    while (current_node != head && count < index - 1) {　　//结束条件：当前结点是头结点
        current_node = current_node->next;
        count++;
    }
    if (count == index - 1) {
        node->next = current_node->next;
        current_node->next = node;
    }
    if (node == head->next) {
        head = node;
    }
    return head;
}

void output_josephus(LinkedList head, int m) {
    Node *current_node = head;
    head = NULL;　　　　//防止head成为野指针
    while (current_node->next != current_node) {
        for (int i = 1; i < m; i++) {
            current_node = current_node->next;
        }
        printf("%d ", current_node->next->data);
        Node *delete_node = current_node->next;
        current_node->next = current_node->next->next;
        free(delete_node);
    }
    printf("%d\n", current_node->data);
    free(current_node);
}

int main() {
    LinkedList linkedlist = NULL;
    int n, m;
    scanf("%d %d", &n, &m);
    for (int i = 1; i <= n; i++) {
        Node *node = (Node *)malloc(sizeof(Node));
        node->data = i;
        node->next = NULL;
        linkedlist = insert(linkedlist, node, i - 1);
    }
    output_josephus(linkedlist, m);
    return 0;
}
```

```c
#incldue <stdio.h>
#include <stdlib.h>

typedef struct Node{
    int data;
    struct Node *next;
    struct Node *prior;
}Node, *LinkedList;

Node insert(LinkedList head, int index, int value) {
    Node *p, ret;
    int raw_index = index, len = 0;
    p = head;
    ret.data = 0;
    while (p && index) {
        p = p->next;
        --index;
        ++len;
        if (p == head) break;
    }
    if (index == 0) {
        Node *node = (Node *)malloc(sizeof(Node));
        node->data = value
        node->next = node;
        if (p != NULL) {
            node->next = p->next;
            p->next = node;
        }
        node->prior = NULL;
        if (p == head && len == raw_index) {
            head = node;
        }
        ret.data = 1;
    }
    ret.next = head;
    return ret;
}

LinkedList build(LinkedList head) {
    Node *p, *q;
    if (head == NULL) {
        return head;
    }
    p = head;
    q = head->next;
    do {
        q->prior = p;
        p = p->next;
        q = q->next;
    } while (q != head->next);
    return head;
}

void output(LinkedList head, int m) {
    int len = 0;
    Node *p = head, *q;
    while (p->data != m) {
        p = p->next;
    }
    q = p;
    printf("%d", p->data);
    p = p->prior;
    while (p != q) {
        printf(" %d", p->data);
        p = p->prior;
    }
    printf("\n");
    return ;
}

void clear(LinkedList head) {
    Node *p, *q;
    if (head == NULL) {
        return ;
    }
    p = head->next;
    head->next = NULL;
    while (p) {
        q = p->next;
        free(p);
        p = q;
    }
    return ;
}
 
int main() {
    LinkedList linkedlist = NULL;
    Node ret;
    int n, m, num;
    scanf("%d", &n);
    for (int i = 0; i < n; ++i) {
        scanf("%d", &num);
        ret = insert(linkedlist, i, num);
        if (ret.data == 0) {
            printf("ERROR\n");
            return 1;
        }
        linkedlist = ret.next;
    }
    linkedlist = build(linkedlist);
    scanf("%d", &m);
    output(linkedlist, m);
    fflush(stdout);
    clear(linkedlist);
    return 0;
}
```

### 队列（先进先出）

出队方案唯一

队首元素先出

新元素插入队尾

```c
#include <stdio.h>
#include <stdlib.h>

#define ERROR 0
#define OK 1

typedef struct Queue {
    int *data;
    int head, tail, length;
} Queue;

void init(Queue *q, int length) {
    q->data = (int *)malloc(sizeof(int) * length);
    q->length = length;
    q->head = 0;
    q->tail = -1;
}

int push(Queue *q, int element) {
    if (q->tail + 1 >= q->length) {
        return ERROR;
    }
    q->tail++;
    q->data[q->tail] = element;
    return OK;
}

void output(Queue *q) {
    for (int i = q->head; i <= q->tail; i++) {
        printf("%d ", q->data[i]);
    }
    printf("\n");
}

int front(Queue *q) {
    return q->data[q->head];
}

void pop(Queue *q) {
    q->head++;
}

int empty(Queue *q) {
    return q->head > q->tail;
}

void clear(Queue *q) {
    free(q->data);
    free(q);
}

int main() {
    Queue *queue = (Queue *)malloc(sizeof(Queue));
    init(queue, 100);
    for (int i = 1; i <= 10; i++) {
        push(queue, i);
    }
    output(queue);
    if (!empty(queue)) {
        printf("%d\n", front(queue));
        pop(queue);
    }
    output(queue);
    clear(queue);
    return 0;
}
```

##### **循环队列**

循环队列里通过统计队列里元素个数，判断能否继续往循环队列里插入元素

在队列里，当tail达到队列上限后，继续插入就有可能发生“假上溢”的情况

在循环队列里，如果容量没有达到上限，当队尾队首标记达到数组上界后，就跳转到数组起始位置

```c
#include <stdio.h>
#include <stdlib.h>

#define ERROR 0
#define OK 1

typedef struct Queue {
    int *data;
    int head, tail, length, count;
}Queue;

void init(Queue *q, int length) {
    q->data = (int *)malloc(sizeof(int) * length);
    q->length = length;
    q->head = 0;
    q->tail = -1;
    q->count = 0;
}

int push(Queue *q, int element) {
    if (q->count >= q->length) {
        return ERROR;
    }
    q->tail = (q->tail + 1) % q->length;
    q->data[q->tail] = element;
    q->count++;
    return OK;
}

void output(Queue *q) {
    int i = q->head;
    do {
        printf("%d ", q->data[i]);
        i = (i + 1) % q->length;
    } while(i != (q->tail + 1) % q->length);
    printf("\n");
}

int front(Queue *q) {
    return q->data[q->head];
}

void pop(Queue *q) {
    q->head = (q->head + 1) % q->length;
    q->count--;
}

int empty(Queue *q) {
    return q->count == 0;
}

void clear(Queue *q) {
    free(q->data);
    free(q);
}

int main() {
    Queue *q = (Queue *)malloc(sizeof(Queue));
    init(q, 100);
    for (int i = 1; i <= 10; i++) {
        push(q, i);
    }
    output(q);
    if (!empty(q)) {
        printf("%d\n", front(q));
        pop(q);        
    }
    output(q);
    clear(q);
    return 0;
}
```

### 栈（先进后出）

栈顶元素先出

栈为空不能出栈

新元素插入栈顶

**出栈规律**：

1. 在原序列中相对位置比它小的，必须是逆序
2. 在原序列中相对位置比它大的，顺序没有要求
3. 以上两点可以间插进行

**n个元素进栈共有多少种出栈顺序**

问题分析

> f(1) = 1     //1
>
> f(2) = 2     //21、12
>
> f(3) = 5     //321、231、213、123、132
>
> f(4):给4个元素编号为a, b, c, d
>
> 1. 如果元素a在1号位置，那么只可能a进栈马上出栈，此时还剩下3个元素，即f(3)
> 2. 如果元素a在2号位置，那么一定有一个元素比a先出栈，即有f(1)种可能顺序（只能是b），还剩2个元素，即f(2)，乘法定理：f(1) * f(2)
> 3. 如果元素a在3号位置，那么一定有2个元素比a先出栈，即有f(2)种可能顺序（只能是b,c）还剩d，即f(1)，乘法定理：f(2) * f(1)
> 4. 如果元素a在4号位置，那么一定是a先进栈，最后出栈，那么元素b, c, d的出栈顺序为f(3)
>
> 结合所有情况，即f(4) = f(3) + f(2) * f(1) + f(1) * f(2) + f(3)
>
> 即f(n) = f(0) * f(n - 1) + f(1) * f(n - 2) + ... + f(n - 1) * f(0)

求解非常规数值分析

> 对于每一个数来说，必须进栈一次、出栈一次，进栈设为状态‘1’，出栈设为状态‘0’。
>
> n个数的所有状态对应n个1和n个0组成的2n位二进制数。
>
> 由于等待入栈的操作数按照1‥n的顺序排列、**入栈的操作数b大于等于出栈的操作数a(a≤b)**，因此输出序列的总数目=由左而右扫描由n个1和n个0组成的2n位二进制数，1的累计数不小于0的累计数的方案种数。
>
> 在2n位二进制数中填入n个1的方案数为c(2n,n),不填1的其余n位自动填0。从中减去不符合要求（由左而右扫描，0的累计数大于1的累计数）的方案数即为所求。
>
> 不符合要求的数的特征是由左而右扫描时，必然在某一奇数位2m+1位上首先出现m+1个0的累计数和m个1的累计数，此后的2(n-m)-1位上有n-m个 1和n-m-1个0。如若把后面这2(n-m)-1位上的0和1互换，使之成为n-m个0和n-m-1个1，结果得1个由n+1个0和n-1个1组成的2n位数，即一个不合要求的数对应于一个由n+1个0和n-1个1组成的排列。
>
> 反过来，任何一个由n+1个0和n-1个1组成的2n位二进制数，由于0的个数多2个，2n为偶数，故必在某一个奇数位上出现0的累计数超过1的累计数。同样在后面部分0和1互换，使之成为由n个0和n个1组成的2n位数，即n+1个0和n-1个1组成的2n位数必对应一个不符合要求的数。
>
> 因而不合要求的2n位数与n+1个0，n-1个1组成的排列一一对应。
>
> 显然，不符合要求的方案数为c(2n,n+1)。
>
> 由此得出输出序列的总数目=c(2n,n)-c(2n,n+1)=**c(2n,n)/(n+1)**。其中，n为节点的个数。

**卡特兰数**

令h(0)=1,h(1)=1，Catalan数满足递推式：h(n) = h(0) * h(n-1) + h(1) * h(n-2) + ... + h(n-1) * h(0) (n >= 2)

h(2) = h(0) * h(1) + h(1) * h(0)=1 * 1 + 1 * 1 = 2

h(3) = h(0) * h(2) + h(1) * h(1) + h(2) * h(0) = 1 * 2 + 1 * 1 + 2 * 1 = 5

另类递推式：h(n) = h(n - 1) * (4 * n - 2) / (n + 1)

递推关系的解为：h(n) = C(2n, n) / (n + 1) (n = 0,1,2,...)

递推关系的另类解为：h(n)=C(2n,n)-C(2n,n+1)(n=0,1,2,...)

```c
#include <stdio.h>
#include <stdlib.h>

#define ERROR 0
#define OK 1

typedef struct Stack {
    int *elements;
    int max_size, top_index;
}Stack;

void init(Stack *s, int length_input) {
    s->elements = (int *)malloc(sizeof(int) * length_input);
    s->max_size = length_input;
    s->top_index = -1;
}

int push(Stack *s, int element) {
    if (s->top_index >= s->max_size - 1) {
        return ERROR;
    }
    s->top_index++;
    s->elements[s->top_index] = element;
    return OK;
}

int pop(Stack *s) {
    if (s->top_index < 0) {
        return ERROR;
    }
    s->top_index--;
    return OK;
}

int top(Stack *s) {
    return s->elements[s->top_index];
}

void clear(Stack *s) {
    free(s->elements);
    free(s);
}

int main() {
    int n, m;
    scanf("%d %d", &n, &m);
    Stack *stack = (Stack *)malloc(sizeof(Stack));
    init(stack, n);
    for (int i = 1; i <= m; i++) {
        int opr;
        scanf("%d", &opr);
        if (opr == 0) {
            int element;
            scanf("%d", &element);
            if (push(stack, element)) {
                printf("push success!\n");
            } else {
                printf("push failed!\n");
            }
        } else if (opr == 1) {
            if (pop(stack)) {
                printf("pop success!\n");
            } else {
                printf("pop failed!\n");
            }
        } else if (opr == 2) {
            printf("%d\n", top(stack));
        }
    }
    clear(stack);
    return 0;
}
```

> **用栈实现数列反转**
>
> 1. 将一个数列的元素依次压入到栈中
> 2. 将栈顶元素出栈
> 3. 判断栈是否为空，不为空则继续

```c
#include <stdio.h>
#include <stdlib.h>

#define ERROR 0
#define OK 1

typedef struct Stack {
    int *elements;
    int max_size, top_index;
} Stack;

void init(Stack *s, int length) {
    s->elements = (int *)malloc(sizeof(int) * length);
    s->max_size = length;
    s->top_index = -1;
}

int push(Stack *s, int element) {
    if (s->top_index >= s->max_size - 1) {
        return ERROR;
    }
    s->top_index++;
    s->elements[s->top_index] = element;
    return OK;
}

int pop(Stack *s) {
    if (s->top_index < 0) {
        return ERROR;
    }
    s->top_index--;
    return OK;
}

int top(Stack *s) {
    return s->elements[s->top_index];
}

// 请在下面实现判断栈是否为空的函数 empty
int empty(Stack *s) {
    if (s->top_index < 0) {
        return 1;
    } else {
        return 0;
    } 
}

void clear(Stack *s) {
    free(s->elements);
    free(s);
}

int main() {
    int n, num;
    scanf("%d", &n);
    Stack *stack = (Stack *)malloc(sizeof(Stack));
    init(stack, n);
    for (int i = 1; i <= n; i++) {
        scanf("%d", &num);
        push(stack, num);
    }
    while (!empty(stack)) {
        printf("%d ", top(stack));
        pop(stack);
    }
    clear(stack);
    return 0;
}
```

> **用栈实现表达式求值**
>
> 1. 使用两个栈分别存储数值和运算符
> 2. 读取表达式字符，数值存入数值栈，运算符和栈顶运算符比较优先级
> 3. 通过运算符优先级不同选择将它压入栈或取出数值栈中两个元素进行计算，计算结果入栈
> 4. 返回步骤２，直至表达式全部读完
> 5. 弹出一个运算符和两个数值进行运算，计算结果存储数值栈
> 6. 当运算复符栈不为空时，返回步骤５，否则数值栈中剩余的最后一个元素就是表达式求值结果

```c
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

#define ERROR 0
#define OK 1

typedef struct Stack {
    int *data;
    int size, top;
} Stack;

void init(Stack *s, int length) {
    s->data = (int *)malloc(sizeof(int) * length);
    s->size = length;
    s->top = -1;
}

int push(Stack *s, int x) {
    if (s->top >= s->size - 1) {
        return ERROR;
    }
    s->top++;
    s->data[s->top] = x;
    return OK;
}

int pop(Stack *s) {
    if (s->top < 0) {
        return ERROR;
    }
    s->top--;
    return OK;
}

int top(Stack *s) {
    return s->data[s->top];
}

int empty(Stack *s) {
    if (s->top < 0) {
        return 1;
    } else {
        return 0;
    }
}

int precede(char a, char b) {
    if ((a == '*' && b == '+') || (a == '*' && b == '-') || (a == '/' && b == '+' || (a == '/' && b == '-'))) {
        return 1;
    } else {
        return 0;
    }
}

int operate(char thata, int a, int b) {
    if (thata == '+') {
        return a + b;
    } else if (thata == '-') {
        return b - a;
    } else if (thata == '*') {
        return a * b;
    } else {
        return b / a;
    }
}

void calc(Stack *numbers, Stack *operators) {
    int a = top(numbers);
    pop(numbers);
    int b = top(numbers);
    pop(numbers);
    push(numbers, operate(top(operators), a, b));
    pop(operators);
}

void clear(Stack *s) {
    free(s->data);
    free(s);
}

int main() {
    int m;
    scanf("%d", &m);
    Stack *numbers = (Stack *)malloc(sizeof(Stack));
    init(numbers, m);
    Stack *operators = (Stack *)malloc(sizeof(Stack));
    init(operators, m);
    char *buffer = (char *)malloc(sizeof(char) * (m + 1));
    scanf("%s", buffer);
    int i = 0;
    while (i < m) {
        if (isdigit(buffer[i])) {
            push(numbers, buffer[i] - '0');
            i++;
        } else {
            if (empty(operators) || precede(buffer[i], top(operators))) {
                push(operators, buffer[i]);
                i++;
            } else {
                calc(numbers, operators);
                //push(operators, buffer[i]);
                //i++;
            }
        }
    }
    while (!empty(operators)) {
        calc(numbers, operators);
    }
    printf("%d\n", top(numbers));
    clear(numbers);
    clear(operators);
    free(buffer);
    return 0;
}
```

#### 逆波兰式

**将中缀表达式转换成后缀表达式算法：**

1. 从左至右扫描一中缀表达式
2. 若读取的是操作数，则判断该操作数的类型，并将该操作数存入操作数堆栈
3. 若读取的是运算符
   1. 该运算符为左括号"("，则直接存入运算符堆栈
   2. 该运算符为右括号")"，则输出运算符堆栈中的运算符到操作数堆栈，直到遇到左括号为止
   3. 该运算符为非括号运算符：
      1. 若运算符堆栈栈顶的运算符为括号（只可能是左括号），则直接存入运算符堆栈
      2. 若比运算符堆栈栈顶的运算符优先级高，则直接存入运算符堆栈。
      3. 若比运算符堆栈栈顶的运算符优先级低或相等，则不断输出栈顶运算符到操作数堆栈，直到栈顶没有运算符的优先级大于或者等于当前预算符（即栈顶存在运算符的话，优先级一定是小于当前运算符），最后将当前运算符压入运算符堆栈。
4. 表达式读取完成后运算符堆栈中尚有运算符时，则依序取出运算符到操作数堆栈，直到运算符堆栈为空。

**逆波兰表达式求值算法：**

1. 从左到右依次扫描语法单元的项目
2. 如果扫描的项目是操作数，则将其压入操作数堆栈，并扫描下一个项目
3. 如果扫描的项目是一个二元运算符，则对栈的顶上两个操作数执行该运算
4. 如果扫描的项目是一个一元运算符，则对栈的最顶上操作数执行该运算
5. 将运算结果重新压入堆栈
6. 重复步骤2-5，堆栈中即为结果值。

#### 括号匹配

1. 在任意一个位置上，左括号数量 >= 右括号数量
2. 在最后一个位置上，左括号数量 == 右括号数量
3. 一对()可以等价为一个完整的事件
4. (())可以看做事件与事件之间的完全包含关系　　-->       **栈可以处理具有完全包含关系的问题（树、函数）**

#### 单调栈

栈内元素从栈顶到栈底单调递增或单调递减的栈

元素加入栈之前，会在栈顶把破坏栈单调性的元素都删除

单调栈里的元素具有单调性

使用从栈顶到栈底单调递减的单调栈可以找到元素向左遍历第一个比它小的元素

> 地上从左到右竖立着n块木板，从1到n一次编号，我们知道每块木板的高度，在第n块木板右侧竖立着一块高度无限大的木板，现对每块木板依次做如下操作：对于第i块木板，我们从其右侧开始倒水，直到水的高度等于第i块木板的高度，倒入的水会淹没ai块木板，求n次操作后，所有的ai的和是多少。

算法：先输入第i块木板的高度，然后标记下木板编号，记录到变量temp里，接着，temp依次和栈顶元素a比较，如果a的高度小于等于temp的高度，则弹出。根据单调栈的性质，元素a出战表明我们已经找到元素a右侧第一个比它大的元素了（这里指的就是temp），元素temp的编号减去a的编号再减1，累加结果后我们进行新的比较，重复上述操作，直到栈顶元素的高度大于temp的高度，然后我们再把temp加入到栈里。循环结束后，我们还需要判断栈是否为空，如果不为空，则依次弹出栈顶元素，操作一样，最后输出结果。

```c
#include <stdio.h>
#include <stdlib.h>

#define ERROR 0
#define OK 1

typedef struct Node {
    int id, height;
} Node;

typedef struct Stack {
    Node *elements;
    int max_size, top_index;
} Stack;

void init(Stack *s, int length) {
    s->elements = (Node *)malloc(sizeof(Node) * length);
    s->max_size = length;
    s->top_index = -1;
}

int push(Stack *s, Node element) {
    if (s->top_index >= s->max_size - 1) {
        return ERROR;
    }
    s->top_index++;
    s->elements[s->top_index] = element;
    return OK;
}

int pop(Stack *s) {
    if (s->top_index < 0) {
        return ERROR;
    }
    s->top_index--;
    return OK;
}

Node top(Stack *s) {
    return s->elements[s->top_index];
}

int empty(Stack *s) {
    if (s->top_index < 0) {
        return 1;
    } else {
        return 0;
    }
}

void clear(Stack *s) {
    free(s->elements);
    free(s);
}

int main() {
    int n, ans = 0;
    scanf("%d", &n);
    Stack *stack = (Stack *)malloc(sizeof(Stack));
    init(stack, n);
    Node temp;
    for (int i = 1; i <= n; i++) {
        scanf("%d", &temp.height);
        temp.id = i;
        while (!empty(stack) && top(stack).height <= temp.height) {
            ans = ans + i - top(stack).id - 1;
            pop(stack);
        }
        push(stack, temp);
    }
    while (!empty(stack)) {
        ans = ans + n + 1 - top(stack).id - 1;
        pop(stack);
    }
    printf("%d\n", ans);
    clear(stack);
    return 0;
}
```

举例描述：

例如n = 5，每块木板分别高10，5，８，12，6。sum用来记录最后的结果，初始为0。

1. 第一块木板高10，栈为空，10入栈；
2. 第二块木板高5，栈顶为10，5入栈；
3. 第三块木板高8，栈顶5比8小，删除栈顶，a2为3 - 2 - 1 = 0，sum = 0。此时栈顶为10，8入栈；
4. 第四块木板高12，栈顶8比12小，删除栈顶，a3为4 - 3 - 1 = 0，sum = 0。此时栈顶为10，比12小，继续删除栈顶，a1为4 - 1 - 1 = 2，sum = 2，此时栈为空，12入栈;
5. 第五块木板高6，栈顶为12，6入栈;
6. 遍历结束后，栈不为空，依次删除栈顶，当前位置为n + 1，栈顶是第五个元素6，a5为6 - 5 - 1 = 0，sum = 2；
7. 继续删除栈顶，此时栈顶是第四个元素12，a4为6 - 4 - 1 = 1，sum = 3，此时栈为空，最后sum为3，输出结果，程序结束。

#### 栈和队列的应用

栈：树的深度遍历、深度优先搜索（图算法基础）

队列（循环）：树的层序遍历、广度优先搜索（图算法基础）

单调栈：临近最大（小）值

单调队列：区间最大（小）值

### 树和二叉树

每棵非空树有且仅有一个根结点

在树上，从一个结点出发可以访问到其余的结点，并且一个结点到另一个结点的路径有且只有一条

父亲结点可以有多个孩子结点，除根结点外，其余的结点有且仅有一个父亲结点

根结点没有父亲结点，叶子结点没有孩子结点

在一棵非空树上，一定会有根结点和叶子结点

高度：从叶子结点往上，叶子结点高度为1

深度：从根结点往下

度：结点有几个分叉，度就是几

对于整棵树来说，最深的叶子结点的深度就是树的深度，根结点的高度就是树的高度

对于树中相同深度的每个结点，它们的高度不一定相同

#### 二叉树

二叉树的每个结点最多只有两个孩子结点。

五种基本形态：

1. 空二叉树（树为空没有结点）
2. 只有根结点的二叉树
3. 只有左子树的二叉树
4. 只有右子树的二叉树
5. 左右子树都有的二叉树

**二叉树第i层最多有2^(i - 1)个结点**

**深度为k的二叉树最多有2^k - 1个结点**

**任意一棵二叉树上，其叶子结点数n0比度为2的结点数n2多1。**我们记树上结点总数为n，度为1的结点个数为n1，则有n = n0 + n1 + n2，另外我们可以发现一棵二叉树一共有n - 1条边，度为2的结点可以延伸出2条边，度为1的结点可以延伸出1条边，叶子结点没有边可以延伸出来，所以又有n - 1 = n1 + 2 * n2，结合这两个式子，可以得到n0 = n2 + 1。

**满二叉树**：如果一棵树深度为k，且有2^k - 1个结点，即在此深度上，不能再添加新的结点了。

**完全二叉树**：如果一棵树深度为k，从第1层到第k - 1层该树是满二叉树，第k层的结点都集中在左边。

​                       编号为i的子节点：左孩子编号：2 * i，右孩子编号：2 * i + 1

完全二叉树上最多有一个度为1的结点。

二叉树的广义表表示形式：

1. a：表示根节点为a，左右孩子节点均为空
2. a(b)：根节点为a，左孩子节点为b，右孩子节点为空
3. a(,c) :根节点为a，左孩子节点为空，右孩子节点为c
4. a(b,c)：根节点为a，左孩子节点为b，右孩子节点为c

> 二叉树烦人创建、存储、遍历（先序遍历、中序遍历、后序遍历）

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct Node {
    int data;
    struct Node *lchild, *rchild;
} Node;

Node* init(int data) {
    Node *node =(Node *)malloc(sizeof(Node));
    node->data = data;
    node->lchild = NULL;
    node->rchild = NULL;
    return node;
}

Node* build_demo() {
    Node *node = init(1);
    node->lchild = init(2);
    node->rchild = init(3);
    node->lchild->lchild = init(4);
    node->lchild->rchild = init(5);
    node->rchild->rchild = init(6);
    return node;
}

void preorder(Node *node) {
    printf("%d ", node->data);
    if (node->lchild != NULL) {
        preorder(node->lchild);
    }
    if (node->rchild != NULL) {
        preorder(node->rchild);
    }
}

void inorder(Node *node) {
    if (node->lchild != NULL) {
        inorder(node->lchild);
    }
    printf("%d ", node->data);
    if (node->rchild != NULL) {
        inorder(node->rchild);
    }
}

// 请在下面实现后序遍历函数 postorder
void postorder(Node *node) {
    if (node->lchild != NULL) {
        postorder(node->lchild);
    }
    if (node->rchild != NULL) {
        postorder(node->rchild);
    }
    printf("%d ", node->data);
}

void clear(Node *node) {
    if (node->lchild != NULL) {
        clear(node->lchild);
    }
    if (node->rchild != NULL) {
        clear(node->rchild);
    }
    free(node);
}

int main() {
    Node *root = build_demo();
    preorder(root);
    printf("\n");
    inorder(root);
    printf("\n");
    postorder(root);
    printf("\n");
    clear(root);
    return 0;
}
```

> 已知先序和中序求后序

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct Node {
    int *data;
    struct Node *lchild, *rchild;
} Node;

Node *init(int data) {
    Node *node = (Node *)malloc(sizeof(Node));
    node->data = data;
    node->lchild = NULL;
    node->rchild = NULL;
    return node;
}

void postorder(Node *node) {
    if (node->lchild != NULL) {
        postorder(node->lchild);
    }
    if (node->rchild != NULL) {
        postorder(node->rchild);
    }
    printf("%d ", node->data);
}

Node *build(char pre_str[], char in_str[], int len) {   //pre_str：先序遍历；in_str：中序遍历；len：in_str的长度（中序遍历的结点个数）
    //先序遍历的第一位是当前的根结点
    Node *p = init(pre_str[0] - '0');
    //中序遍历能找到根结点的位置pos，pos前面是左子树，后面是右子树
    int pos = strchr(in_str, pre_str[0]) - in_str;   //strchr返回地址，减去首地址得到pos
    if (pos > 0) {   //pos等于0则左子树为空
        p->lchild = build(pre_str + 1, in_str, pos);  //pre_str + 1左子树的先序遍历，从pre_str第一位开始，in_str左子树的中序遍历，从in_str第0位开始，pos左子树中序遍历的长度
    }
    if (len - pos - 1 > 0) {
        p->rchild = build(pre_str + pos + 1, in_str + pos + 1, len - pos - 1);
    }
    return p;
}

void clear(Node *node) {
    if (node->lchild != NULL) {
        clear(node->lchild);
    }
    if (node->rchild != NULL) {
        clear(node->rchild);
    }
    free(node);
}

int main() {
    char pre_str[] = "136945827";
    char in_str[] = "963548127";
    Node *root = build(pre_str, in_str, strlen(pre_str));
    postorder(root);
    printf("\n");
    clear(root);
    return 0;
}
```

#### 哈夫曼编码

无损数据压缩的编码算法

哈夫曼编码先统计出每种字母在字符串里出现的频率，根据频率建立一棵路径带权的二叉树，即哈夫曼树，树上每个结点存储字母出现的频率，根结点到结点的路径即是字母的编码，频率高的字母使用较短的编码，频率低的字母使用较长的编码，这样使得编码后的字符串占用空间最小。

首先统计每个字母在字符串里出现的频率，把每个字母看成结点，结点的权值即是字母出现的频率

1. 从集合里取出两个根结点权值最小的树a和b，构造出一颗新的二叉树c，二叉树c的根结点的权值为a和b的根结点权值和，二叉树c的左右子树分别是a和b
2. 将二叉树a和b从集合里删除，把二叉树c加入集合里

重复直至集合里只剩下一棵二叉树

规定每个有孩子结点的结点，到左孩子结点的路径为0，到右孩子结点的路径为1。每个结点的编码就是根结点到字母对应结点的路径。

哈夫曼树的WPL（树的带权路径长度），等于编码后字符串所占的比特数。

在哈夫曼树上，相对来说，权值大的结点离根结点近，权值小的离根结点远。

哈夫曼编码每次从集合里取出根结点权值最小的两棵二叉树构成新的二叉树。

哈夫曼树上不会存在只有一个孩子结点的结点。

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define CHAR_NUM 26

#define swap(a, b) { \
    __typeof(a) temp; \
    temp = a; \
    a = b;  \
    b = temp; \
}

typedef struct HFNode {
    char ch;
    int freq;
    struct HFNode *lchild, *rchild;
} HFNode;

HFNode *getNode() {
    HFNode *p = (HFNode *)malloc(sizeof(HFNode));
    p->freq = p->ch = 0;
    p->lchild = p->rchild = NULL;
    return p;
}

void build(int n, HFNode *arr[n]) {
    for (int times = 0; times < n - 1; times++) {
        HFNode *minNode = arr[0];
        int ind = 0;
        for (int i = 1; i < n - times; i++) {
            if (arr[i]->freq >= minNode->freq) continue;
            minNode = arr[i];
            ind = i;
        }
        swap(arr[ind], arr[n - times - 1]);
        minNode = arr[0];
        ind = 0;
        for (int i = 1; i < n - times - 1; i++) {
            if (arr[i]->freq >= minNode->freq) continue;
            minNode = arr[i];
            ind = i;
        }
        swap(arr[ind], arr[n - times - 2]);
        HFNode *new_node = getNode();
        new_node->lchild = arr[n - times - 1];
        new_node->rchild = arr[n - times - 2];
        new_node->freq = arr[n - times - 1]->freq + arr[n - times - 2]->freq;
        arr[n - times - 2] = new_node;
    }
    return ;
}

void extract(HFNode *root, char *buff, char (*huffman_code)[100], int n) {
    buff[n] = '\0';
    if (root->lchild == NULL && root->rchild == NULL) {
        strcpy(huffman_code[root->ch], buff);
        return ;
    }
    buff[n] = '0';
    extract(root->lchild, buff, huffman_code, n + 1);
    buff[n] = '1';
    extract(root->rchild, buff, huffman_code, n + 1);
    return ;
}

int main() {
    HFNode *arr[CHAR_NUM] = {0};
    char buff[100];
    char huffman_code[256][100] = {0};
    int freq;
    for (int i = 0; i < CHAR_NUM; i++) {
        scanf("%s%d", buff, &freq);
        printf("read %s = %d\n", buff, freq);
        HFNode *new_node = getNode();
        new_node->ch = buff[0];
        new_node->freq = freq;
        arr[i] = new_node;
    }
    build(CHAR_NUM, arr);
    extract(arr[0], buff, huffman_code, 0);
    for (int i = 0; i < 256; i++) {
        if (huffman_code[i][0] == 0) continue;
        printf("%c : %s\n", (char)i, huffman_code[i]);
    }
    return 0;
}
```

> 二叉树的广义表解析

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct Node {
    char key;
    struct Node *lchild, *rchild;
} Node;

Node *getNewNode(char ch) {
    Node *p = (Node *)malloc(sizeof(Node));
    p->key = ch;
    p->lchild = p->rchild = NULL;
    return p;
}

Node *build(char *str, Node *root, int init) {
    if (str[0] == 0) return NULL;
    static int i;
    if (init == 1) i = 0;
    Node *p = NULL; int flag = 0;
    while (str[i]) {
        switch (str[i]) {
            case '(' : {
                i += 1;
                p = build(str, p, 0);
            } break;
            case ')' : {
                if (root == NULL) return p;
                return root;
            } break;
            case ',' : {
                flag = 1;
            } break;
            case ' ' : {
            } break;
            default : {
                p = getNewNode(str[i]);
                if (root != NULL) {
                    if (flag == 0) root->lchild = p;
                    else root->rchild = p;
                }
            } break;
        }
        i += 1;
    }
    return (root ? root : p);
}

void output(Node *root) {
    if (root == NULL) return ;
    output(root->lchild);
    printf("%c ", root->key);
    output(root->rchild);
    return ;
}

int main() {
    char str[1000];
    while (scanf("%[^\n]s", str) != EOF) {
        getchar();
        printf("read = %s\n", str);
        Node *p = build(str, NULL, 1);
        output(p); printf("\n");
    }
    return 0;
}
```

### 图

图是由一系列顶点和若干连结顶点集合内两个顶点的边组成的数据结构。

**有向边和无向边**

一条有向边必然是从一个点指向另一个点，而相反方向的边在有向图中则不一定存在；

而有时候我们并不在意构成一条边的两个顶点具体谁先谁后，这样得到的一条边就是无向边。

对于图而言，如果图中所有的边都是无向边，则称为**无向图**，反之称为**有向图**。

有很少边或弧（如e < nlogn，e指边数，n指点数）的图称为**稀疏图**，反之称为**稠密图**。

**有向图**

顶点的入度是指以顶点为弧头的弧的数目，也就是以该顶点为终点的弧的数目

顶点的出度是指以顶点为弧尾的弧的数目，也就是以该顶点为起点的弧的数目

在有向图里，顶点的度为入度与出度之和

在图里，图的边数等于所有顶点度数和的一半

**图的存储结构**

1. **邻接矩阵**（稠密图使用）

   用一维数组存储图中顶点的信息，用矩阵表示图中各顶点之间的邻接关系

   图的邻接矩阵是唯一的，矩阵的大小只与顶点的个数N有关，是一个N * N的矩阵

   无向图的邻接矩阵是一个对称矩阵

   **用邻接矩阵计算顶点的入度和出度**

   顶点的出度：邻接矩阵上点对应行上所有值的总和

   顶点的入度：邻接矩阵上点对应列上所有值的总和

2. **邻接表**（稀疏图使用）

   图的一种顺序存储与链式存储相结合的存储方法

   在无向图的邻接表中，顶点vi的度为第i个单链表中的结点数，而在有向图中，第i个单链表中的结点数表示的是顶点vi的出度，如果要求入度，则要遍历整个邻接表。

   在邻接表中，我们很容易就能知道某一顶点和哪些顶点相连接

查询两个顶点之间是否有边，邻接矩阵比邻接表更方便

查询两个顶点是否有边，如果用邻接矩阵，可以在矩阵中直接访问两个下标查看两个顶点之间是否有边，而用邻接表则需要在链表中逐个查找。

> 邻接矩阵
>
> 给出一个包含有向图和无向图的混合图G，图上有n个点和m条边，使用邻接矩阵来存储该混合图G并按格式输出邻接矩阵
>
> 输入第一行为两个正整数n和m，表示混合图上的n个点和m条边。接下来输出m行，每行输入三个整数a，x，y，表示点x和点y之间有一条边。如果a = 0，则表示该边为有向边，如果a = 1，则表示该边为无向边。
>
> 输出一个n * n的邻接矩阵，矩阵中第i行第j列的值描述了点i到点j的连边情况，如果值为0表示点i到点j没有边相连，值为1表示有边相连。在每一行中，每两个整数之间用一个空格隔开，最后一个整数后面没有空格。
>
> 样例输入：
>
> ```
> 4 4
> 0 0 1
> 1 0 2
> 0 3 1
> 1 2 3
> ```
>
> 样例输出：
>
> ```
> 0 1 1 0
> 0 0 0 0
> 1 0 0 1
> 0 1 1 0
> ```

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_N 500

typedef struct Graph {
    int mat[MAX_N][MAX_N];
    int n;
}Graph;

void init(Graph *g, int len) {
    g->n = len;
    memset(g->mat, 0, sizeof(g->mat));
}

void insert(Graph *g, int a, int x, int y) {
    if (x < 0 || x >= g->n || y < 0 || y >= g->n) {
        return ;
    }
    if (a == 0) {
        g->mat[x][y] = 1;
    } else if (a == 1) {
        g->mat[x][y] = 1;
        g->mat[y][x] = 1;
    }
}

void output(Graph *g) {
    for (int i = 0; i < g->n; i++) {
        for (int j = 0; j < g->n; j++) {
            if (j == 0) {
                printf("%d", g->mat[i][j]);
            } else {
            	printf(" %d", g->mat[i][j]);
            }
        }
        printf("\n");
    }
}

int main() {
    int n, m, a, x, y;
    scanf("%d %d", &n, &m);
    Graph *g = (Graph *)malloc(sizeof(Graph));
    init(g, n);
    for (int i = 0; i < m; i++) {
        scanf("%d %d %d", &a, &x, &y);
        insert(g, a, x, y);
    }
    output(g);
    free(g);
    return 0;
}
```

> 邻接表
>
> 给出一个包含有向图和无向图的混合图G，图上有n个点和m条边，使用邻接表来存储该混合图G并按格式输出邻接表
>
> 输入第一行为两个正整数n和m，表示混合图上的n个点和m条边。接下来输出m行，每行输入三个整数a，x，y，表示点x和点y之间有一条边。如果a = 0，则表示该边为有向边，如果a = 1，则表示该边为无向边。
>
> 输出邻接表，输出n行，第i行表示第i个点的连边情况，首先输出i，接着输出：，然后输出所有点i能到达的点的编号，边关系中后出现的点先输出。每个整数前有一个空格。
>
> 样例输入：
>
> ```
> 4 4
> 0 0 1
> 1 0 2
> 0 3 1
> 1 2 3
> ```
>
> 样例输出：
>
> ```
> 0: 2 1
> 1:
> 2: 3 0
> 3: 2 1
> ```

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_N 10000

typedef struct Node {
    int vertex;
    struct Node *next;
} Node, *LinkedList;

LinkedList insert_node(LinkedList head, int index) {
    Node *node = (Node *)malloc(sizeof(Node));
    node->vertex = index;
    node->next = head;
    head = node;
    return head;
}

typedef struct Graph {
    LinkedList edges[MAX_N];
    int n;
} Graph;

void init(Graph *g, int n) {
    g->n = n;
    for (int i = 0; i < g->n; i++) {
        g->edges[i] = NULL;
    }
}

void insert(Graph *g, int a, int x, int y) {
    if (x < 0 || x >= g->n || y < 0 || y >= g->n) {
        return ;
    }
    if (a == 0) {
        g->edges[x] = insert_node(g->edges[x], y);
    }
    if (a == 1) {
        g->edges[x] = insert_node(g->edges[x], y);
        g->edges[y] = insert_node(g->edges[y], x);
    }
}

void output(Graph *g) {
    for (int i = 0; i < g->n; i++) {
        printf("%d:", i);
        for (Node *j = g->edges[i]; j != NULL; j = j->next) {
            printf(" %d", j->vertex);
        }
        printf("\n");
    }
}

void clear(Graph *g) {
    for (int i = 0; i < g->n; i++) {
        Node *head = g->edges[i];
        while (head != NULL) {
            Node *delete_node = head;
            head = head->next;
            free(delete_node);
        }
    }
    free(g);
}

int main() {
    int m, n, a, x, y;
    scanf("%d %d", &m, &n);
    Graph *g = (Graph *)malloc(sizeof(Graph));
    init(g, m);
    for (int i = 0; i < n; i++) {
        scanf("%d %d %d", &a, &x, &y);
        insert(g, a, x, y);
    }
    output(g);
    clear(g);
    return 0;
}
```

#### 图的遍历和生成树

图的遍历：从图的某个顶点出发，沿图中的路径依次访问图中所有的顶点，并且使得图中所有顶点都恰好被访问一次。（特指连通图）

遍历算法：深度优先搜索（DFS)和广度优先搜索（BFS）

生成树：根结点便是我们对图进行遍历时的起始顶点，包含图中的所有顶点。

对于一个图，可能会有很多种合法的生成树。

##### 深度优先搜索（DFS）

过程：

1. 访问当前顶点v，并将顶点标记为已访问。

                        2. 遍历与顶点v相邻的所有顶点c，然后对顶点v所有尚未被访问的相邻顶点c，递归地执行第一步操作。如果当前顶点已经没有未访问的相邻顶点了，则说明该分支搜索结束，沿通路回溯到顶点v。
                        3. 此时如果还有相邻顶点没有被访问，则从该顶点继续开始深度优先搜索。直至所有顶点都被访问。

对一个图进行深度优先搜索，其实是在对该图的一个生成树进行搜索，这棵生成树称为深度优先搜索树。

我们可以借助栈来实现深度优先搜索。

深度优先搜索的起点不固定，可以任意选择一个顶点作为起点。

一个连通图可以有多棵深度优先搜索树。

深度优先搜索遍历方法，总是沿着某一深度进行搜索，尽可能深的搜索与当前相邻的顶点。

> 输入第一行为两个整数n和m，代表图中的顶点数和边数。接下来的m行，每行输入两个整数x和y，表示一条从x连向y的无向边。之后输入一个整数k，表示深度优先搜索的起点。
>
> 输出深度优先搜索的遍历结果，每个元素各占一行。
>
> 样例输入：
>
> ```
> 5 6
> 0 1
> 1 2
> 1 3
> 2 3
> 0 4
> 1 4
> 0
> ```
>
> 样例输出：
>
> ```
> 0
> 4
> 1
> 3
> 2
> ```

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_N 10000

typedef struct Node {
    int vertex;
    struct Node *next;
} Node, *LinkedList;

LinkedList insert_node(LinkedList head, int index) {
    Node *node = (Node *)malloc(sizeof(Node));
    node->vertex = index;
    node->next = head;
    head = node;
    return head;
}

typedef struct Graph {
    LinkedList edges[MAX_N];
    int n;
    int visited[MAX_N];
} Graph;

void init(Graph * g, int n) {
    g->n = n;
    for (int i = 0; i < g->n; ++i) {
        g->edges[i] = NULL;
    }
    memset(g->visited, 0, sizeof(g->visited));
}

void insert(Graph *g, int x, int y) {
    if (x < 0 || x >= g->n || y < 0 || y >= g->n) {
        return ;
    }
    g->edges[x] = insert_node(g->edges[x], y);
    g->edges[y] = insert_node(g->edges[y], x);
}

void clear(Graph *g) {
    for (int i = 0; i < g->n; ++i) {
        Node *head = g->edges[i];
        while (head != NULL) {
            Node *delete_node = head;
            head = head->next;
            free(delete_node);
        }
    }
    free(g);
}

void dfs(Graph *g, int index) {
    printf("%d\n", index);
    g->visited[index] = 1;
    for (Node *adj = g->edges[index]; adj != NULL; adj = adj->next) {
        if (!g->visited[adj->vertex]) {
            dfs(g, adj->vertex);
        }
    }
}

int main() {
    int n, m, k;
    scanf("%d %d", &n, &m);
    Graph *graph = (Graph *)malloc(sizeof(Graph));
    init(graph, n);
    for (int i = 0; i < m; ++i) {
        int x, y;
        scanf("%d %d", &x, &y);
        insert(graph, x, y);
    }
    scanf("%d", &k);
    dfs(graph, k);
    clear(graph);
    return 0;
}
```

##### 广度优先搜索（BFS）

通常用于求起点到各点的最短路径，以及求两点之间的最优路径问题。

过程：

1. 选择图中任意一个顶点v作为起点进行访问，并将顶点v标记为已访问。
2. 遍历并访问与顶点v相邻且未被访问的所有顶点c1,c2,...,ck，接着遍历并访问与顶点c1,c2,..,ck相邻且未被访问的顶点，也就是依次访问所有相邻顶点的相邻顶点，以此类推，直至所有顶点都被访问。

对一个连通图进行广度优先搜索，其实是在对该图的一个生成树进行搜索，这个生成树称为广度优先搜索树。

广度优先搜索遍历方法，总是从起点扩散性的搜索。

广度优先搜索的起点不固定，可以任意选择一个顶点作为起点。

我们可以借助队列来实现广度优先搜索。

一个连通图可以有多棵广度优先搜索树。

> 输入第一行为两个整数n和m，代表图中的顶点数和边数。接下来的m行，每行输入两个整数x和y，表示一条从x连向y的无向边。之后输入一个整数k，表示广度优先搜索的起点。
>
> 输出广度优先搜索的遍历结果，每个元素各占一行。
>
> 样例输入：
>
> ```
> 5 6
> 0 2
> 0 3
> 1 2
> 1 3
> 2 3
> 2 4
> 3
> ```
>
> 样例输出：
>
> ```
> 3
> 2
> 1
> 0
> 4
> ```

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_N 10000

typedef struct Queue {
    int *data;
    int head, tail, length;
} Queue;

void init_queue(Queue *q, int length_input) {
    q->data = (int *)malloc(sizeof(int) * length_input);
    q->length = length_input;
    q->head = 0;
    q->tail = -1;
}

void push(Queue *q, int element) {
    if (q->tail + 1 < q->length) {
        q->tail++;
        q->data[q->tail] = element;
    }
}

int front(Queue *q) {
        return q->data[q->head];
}

void pop(Queue *q) {
        q->head++;
}

int empty(Queue *q) {
    if (q->head > q->tail) {
        return 1;
    } else {
        return 0;
    }
}

void clear_queue(Queue *q) {
    free(q->data);
    free(q);
}

typedef struct Node {
    int vertex;
    struct Node *next;
}Node, *LinkedList;

LinkedList insert_node(LinkedList head, int index) {
    Node *node = (Node *)malloc(sizeof(Node));
    node->vertex = index;
    node->next = head;
    head = node;
    return head;
}

typedef struct Graph {
    LinkedList edges[MAX_N];
    int visited[MAX_N];
    int n;
}Graph;

void init_graph(Graph *g, int n) {
    g->n = n;
    memset(g->visited, 0, sizeof(g->visited));
    for (int i = 0; i < g->n; ++i) {
        g->edges[i] = NULL;
    }
}

void insert(Graph *g, int x, int y) {
    if (x < 0 || x >= g->n || y < 0 || y >= g->n) {
        return ;
    }
    g->edges[x] = insert_node(g->edges[x], y);
    g->edges[y] = insert_node(g->edges[y], x);
}

void clear_graph(Graph *g) {
    for (int i = 0; i < g->n; ++i) {
        Node *head = g->edges[i];
        while (head != NULL) {
            Node *delete_node = head;
            head = head->next;
            free(delete_node);
        }
    }
    free(g);
}

void bfs(Graph *g, int id) {
    Queue *queue = (Queue *)malloc(sizeof(Queue));
    init_queue(queue, g->n);
    push(queue, id);
    g->visited[id] = 1;
    while (!empty(queue)) {
        int vertex = front(queue);
        printf("%d\n", vertex);
        pop(queue);
        for (Node *adj = g->edges[vertex]; adj != NULL; adj = adj->next) {
            if (!g->visited[adj->vertex]) {
                g->visited[adj->vertex] = 1;
                push(queue, adj->vertex);
            }
        }
    }
    clear_queue(queue);
}

int main() {
    int n, m, k;
    scanf("%d %d", &n, &m);
    Graph *graph = (Graph *)malloc(sizeof(Graph));
    init_graph(graph, n);
    for (int i = 0; i < m; ++i) {
        int x, y;
        scanf("%d %d", &x, &y);
        insert(graph, x, y);
    }
    scanf("%d", &k);
    bfs(graph, k);
    clear_graph(graph);
    return 0;
}
```

### 堆和优先队列

#### 堆（完全二叉树）

大顶堆：对于堆上的任意一个结点来说，越接近顶部， 结点的权值也就越大，并且它的权值大于等于它所在子树的所有结点的权值

小顶堆：对于堆上的任意一个结点来说，越接近顶部， 结点的权值也就越小，并且它的权值小于等于它所在子树的所有结点的权值

大（小）顶堆最大（小）的结点在根结点->**维护最大最小值**

**堆存储结构（本质、实现方式）：数组**

堆的插入和删除操作的时间复杂度为O(logN)

堆排序的时间复杂度为O(NlogN)

**插入操作**

1. 把新元素保存在数组的最后
2. 找到新插入元素的父节点位置
3. 将新元素与父节点比较大小
4. 若新插入元素与其父结点大小不符合堆序性则交换它和父节点的位置，并回到步骤2，若符合则插入操作完成

**删除操作**

1. 将堆顶元素和最后一个元素交换
2. 删除堆的最后一个元素
3. 自顶向下调整元素的位置，使之满足堆序性

**堆排序**

1. 将变量i设为堆末下标
2. 交换堆顶和第i个元素
3. 自上向下调整堆顶到第i个元素之间的堆结构，使之保持堆序性
4. 将i前移一位，重复步骤2，直至i等于1

> 实现大顶堆，从大到小排序
>
> 输入三行，第一行为一个整数n，代表要插入到堆中的元素的个数；第二行为n个整数，代表要插入到堆中的元素；第三行为一个整数m，代表进行m次删除堆顶的操作。
>
> 首先输出m行，输出每次删除堆顶操作前的堆顶元素，之后再输出两行，第一行的输出内容为：在执行完插入及删除操作后，所有元素遍历输出结果，第二行的输出内容为：在执行完所有操作后，将堆进行从小到大排序后输出的结果，这两行的输出，每个整数后面输出一个空格。
>
> 样例输入：
>
> ```
> 6
> 4 2 6 1 3 5
> 2
> ```
>
> 样例输出：
>
> ```
> 6
> 5
> 4 3 2 1 
> 1 2 3 4 
> ```

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct Heap {
    int *data, size;
} Heap;

void init(Heap *h, int length_input) {
    h->data = (int *)malloc(sizeof(int) * length_input);
    h->size = 0;
}

void swap(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

void push(Heap *h, int value) {
    h->data[h->size] = value;
    int current = h->size;
    int father = (current - 1) / 2;
    while (h->data[current] > h->data[father]) {
        swap(&h->data[current], &h->data[father]);
        current = father;
        father = (current - 1) / 2;
    }
    h->size++;
}

void output(Heap *h) {
    for (int i = 0; i < h->size; i++) {
        printf("%d ", h->data[i]);
    }
    printf("\n");
}

int top(Heap *h) {
    return h->data[0];
}

void update(Heap *h, int pos, int n) {
    int lchild = 2 * pos + 1, rchild = 2 * pos + 2;
    int max_value = pos;
    if (lchild < n && h->data[lchild] > h->data[max_value]) {
        max_value = lchild;
    }
    if (rchild < n && h->data[rchild] > h->data[max_value]) {
        max_value = rchild;
    }
    if (max_value != pos) {
        swap(&h->data[max_value], &h->data[pos]);
        update(h, max_value, n);
    }
}

void pop(Heap *h) {
    swap(&h->data[h->size - 1], &h->data[0]);
    h->size--;
    update(h, 0, h->size);
}

void heap_sort(Heap *h) {
    for (int i = h->size - 1; i >= 1; i--) {
        swap(&h->data[i], &h->data[0]);
        update(h, 0 , i);
    }
}

void clear(Heap *h) {
    free(h->data);
    free(h);
}

int main() {
    int n, m,value;
    scanf("%d", &n);
    Heap *h = (Heap *)malloc(sizeof(Heap));
    init(h, 100);
    for (int i = 0; i < n; i++) {
        scanf("%d", &value);
        push(h, value);
    }
    scanf("%d", &m);
    for (int i = 0; i < m; i++) {
        printf("%d\n", top(h));
        pop(h);
    }
    output(h);
    heap_sort(h);
    output(h);
    return 0;
}
```

#### 优先队列

优先队列内部一般是用堆来实现的，堆的插入、删除操作的时间复杂度都是O(logN)，自然优先队列的插入、删除操作的时间复杂度也都是O(logN)，堆中的堆顶元素就是优先队列的队首元素

在C++的STL里，有封装好的优先队列priority_queue，它包含在头文件\<queue>里。优先级可以自己定义，默认优先级是权值大的元素优先级高。

**优先队列解哈夫曼编码问题**

首先用所有的结点建堆，然后进入循环迭代，每一步都依次取出当前权值最小的两个节点，用它们的和作为一个新节点插入到堆中。

> 一共有8个字符，每个字符均出现了1次，哈夫曼树的WPL = 24
>
> 8个字符，每个频率都是1，这样构成的哈夫曼树就是一棵高度为4的满二叉树，每个节点到根节点的举例为3，WPL = 8 * 3

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct Heap {
    int *data, size;
} Heap;

void init(Heap *h, int length_input) {
    h->data = (int *)malloc(sizeof(int) * length_input);
    h->size = 0;
}

void swap(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

void push(Heap *h, int value) {
    h->data[h->size] = value;
    int current = h->size;
    int father = (current - 1) / 2;
    while (h->data[current] < h->data[father]) {
        swap(&h->data[current], &h->data[father]);
        current = father;
        father = (current - 1) / 2;
    }
    h->size++;
}

int top(Heap *h) {
     return h->data[0];
}

void update(Heap *h, int pos, int n) {
    int lchild = 2 * pos + 1, rchild = 2 * pos + 2;
    int max_value = pos;
    if (lchild < n && h->data[lchild] < h->data[max_value]) {
        max_value = lchild;
    }
    if (rchild < n && h->data[rchild] < h->data[max_value]) {
        max_value = rchild;
    }
    if (max_value != pos) {
        swap(&h->data[pos], &h->data[max_value]);
        update(h, max_value, n);
    }
}

void pop(Heap *h) {
    swap(&h->data[0], &h->data[h->size - 1]);
    h->size--;
    update(h, 0, h->size);
}

int heap_size(Heap *h) {
    return h->size;
}

void clear(Heap *h) {
    free(h->data);
    free(h);
}

int main() {
    int n , value, ans = 0;
    scanf("%d", &n);
    Heap *heap = (Heap *)malloc(sizeof(Heap));
    init(heap, n);
    for (int i = 1; i <= n; i++) {
        scanf("%d", &value);
        push(heap, value);
    }
    if (n == 1) {
            ans += top(heap);
    }
    while (heap_size(heap) > 1) {
        int a = top(heap);
        pop(heap);
        int b = top(heap);
        pop(heap);
        ans = ans + a + b;
        push(heap, a + b);
    }
    printf("%d\n", ans);
    clear(heap);
    return 0;
}
```

1. 一亿个无序数找到10个最小数：10个元素的大顶堆，每次跟堆顶比较
2. 一亿个无序数找到10个最大数：10个元素的小顶堆，每次跟堆顶比较
3. 无序数组排序，每个数字新的位置和原来位置差不超过10：10个元素的小顶堆，堆顶出堆，新元素入堆O(nlog2^10)

### 哈希表

哈希表又叫**散列表**，**关键值通过哈希函数映射到数组上，查找时通过关键值直接访问数组**。

哈希函数指的是关键值和存储位置建立的对应关系，查找时只要根据这个关系就能找到目标位置。一般只要通过一次查找就能找到目标位置，但有些关键字需要多次比较和查找才能找到，因为哈希表中可能存在关键字不同但是哈希地址相同的情况，也就是产生了冲突。一般情况下，冲突是不可避免的，因为关键字集合往往比哈希地址集合大很多。

要提高哈希表的查找效率，关键在于合理的构造哈希函数和优秀的解决冲突的方法。

**哈希函数构造方法：**

**直接寻址法**，即取关键字的值或者关键字的某个函数变换值，线性的映射到存储地址上。（关键字的数量和跨度不是很大）

**除留余数法**，我们将关键字对整数p取的余数直接作为存储地址，整数p一般取小于等于哈希表长度size的最大质数，如果关键字不是整数，比如是一个字符串，可以先将其做个转换，然后再对p取余。选择优秀的p可以减少冲突的产生。

设计哈希函数：计算简单，计算复杂的哈希函数会增加查询的时间；关键字尽可能地均分到存储地址上，这样可以减少冲突。

**处理冲突的方法：**

**开放地址法**，如果发生冲突，那么就使用某种策略寻找下一存储地址，直到找到一个不冲突的地址或者找到关键字，否则一直按这种策略继续寻找。如果冲突次数达到了上限则终止程序，表示关键字不存在哈希表里。

常见策略：

1. **线性探测法**，如果当前的冲突位置为d，那么接下来几个探测位置为d + 1，d + 2，d + 3等，也就是从冲突地址往后面一个一个探测；

   流程：

   1. 用哈希函数找到字符串s的初始位置，初始化冲突次数
   2. 从当前位置往后查找，找到第一个未发生冲突的位置k（当前位置上如果存储的字符串不是s即视为发生冲突）。查找过程中记录发生冲突的次数t，如果t大于等于表长，则结束算法，表示查找失败
   3. 如果位置k上的元素就是所查找的字符串，表示查找成功，否则表示查找失败。

2. **线性补偿探测法**，它形成的探测地址为d + m，d + 2 * m，d + 3 * m等，与线性探测法不同，这里的查找单位不是1，而是m，为了能遍历到哈希表里所有位置，我们设置m和表长size互质；

3. **随机探测法**，这种方法和前两种方法类似，这里的查找单位不是一个固定值，而是一个随机序列；

4. **二次探测法**，它形成的探测地址为d + 1 ^ 2，d - 1 ^ 2，d + 2 ^ 2，d - 2 ^ 2等，这种方法在冲突位置左右跳跃着寻找探测地址。

缺点：

1. **线性探测法容易形成”聚堆“的情况**，即很多记录就连在一块，而且一旦形成”聚堆“，记录会越聚越多。
2. 删除操作十分复杂，**不能直接删除关键字所在记录**，否则在查找删除位置后面的元素时，可能会出现找不到的情况，因为删除位置上已经成了空地址，查找到这里时会终止查找。

在元素插入哈希表中时调用线性探测法去获知冲突情况，程序执行时，如果当前的元素已经存在哈希表中了，就直接返回一个值结束这次插入操作。除此之外，我们规定，当冲突次数小于表长的一半时，我们就可以把字符串插入到哈希表中。而如果发生冲突次数大于表长的一半时，就需要调用重建函数去重建哈希表了。

哈希表重建操作：

1. 开辟一段和当前哈希表等大的临时存储空间
2. 将原哈希表里的关键字一一复制到临时数组里
3. 申请一个大小是现在两倍的新的存储空间，释放原空间
4. 将新空间里的存储地址初始化
5. 将关键字从临时数组复制到新的空间，释放临时空间

**链地址法**，该方法将所有哈希地址相同的结点构成一个单链表，单链表的头结点存在哈希数组里，链地址法常出现在经常插入和删除的情况下。

相比开放地址法，链地址法有以下优点，**不会出现”聚堆“现象**，哈希地址不停地关键字不会发生冲突；不需要重建哈希表，在开放地址法中，如果哈希表里存满了关键字了就需要扩充哈希表然后重建哈希表，而在链地址法里，因为**结点都是动态申请的，所以不会出现哈希表里存满关键字的情况**，相比开放地址法，**关键字删除更方便**，只需要找到指定结点，删除该结点即可。

**当关键字规模少的时候，开放地址法比链地址法更节省空间**，因为用链地址法可能会存在哈希数组出现大量空地址的情况，而在**关键字规模大的情况下，链地址法就比开放地址法更节省空间**，链表产生的指针域可以忽略不计，关键字多，哈希数组里产生的空地址就少了。

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct HashTable {
    char **elem;    //存储关键字
    int size;　　　//表示哈希表的容量
} HashTable;

void init(HashTable *h);
int hash(HashTable *h, char value[]);
int search(HashTable *h, char value[], int *pos, int *times);
int insert(HashTable *h, char value[]);
void recreate(HashTable *h);

void init(HashTable *h) {
    h->size = 2000;
    h->elem = (char **)malloc(sizeof(char *) * h->size);
    for (int i = 0; i < h->size; i++) {
        h->elem[i] = NULL;
    }
}

//构造哈希函数
int hash(HashTable *h, char value[]) {
    int code = 0;　　//记录字符串value的哈希值，也就是对应的存储位置
    for (size_t i = 0; i < strlen(value); i++) {
        //有符号的字符范围是从-128到127，也就是共256种，可能会出现负值，最后+128，为防止数据过大导致的数据溢出，对哈希表的长度h->size取余
        code = (code * 256 + value[i] + 128) % h->size;
    }
    return code;
}

//哈希查找函数
int search(HashTable *h, char value[], int *pos, int *times) {　　//value表示要查找的字符串，pos表示哈希表里可以插入value的位置，times记录冲突的次数
    *pos = hash(h, value);
    *times = 0;
    //如果当前位置pos为空地址则表示可以插入value，如果pos上已有关键字，并且关键字就是value，说明value已经插入到哈希表里了，如果pos上已有关键字，并且关键字不是value，说明发生冲突了，需要找下一个地址
    while (h->elem[*pos] != NULL && strcmp(h->elem[*pos], value) != 0) {
        (*times)++;　　　//冲突次数加一
        if (*times < h->size) {　　　　//判断哈希表是否还有位置可以插入
            *pos = (*pos + 1) % h->size;　　　//线性探测法
        } else {
            return 0;
        }
    }
    if (h->elem[*pos] != NULL && strcmp(h->elem[*pos], value) == 0) {
        return 1;　　　//找到
    } else {
        return 0;     //哈希表里没有value，当前位置可以插入value
    }
}

//插入：调用search函数，如果哈希表里已有该元素则不作处理，如果冲突次数没达到哈希表长度的一半，则插入到哈希表，如果冲突次数达到哈希表长度的一半，则需要重建哈希表，表示插入失败
int insert(HashTable *h, char value[]) {
    int pos, times;
    if (search(h, value, &pos, &times)) {
        return 2;
    } else if (times < h->size / 2) {
        h->elem[pos] = (char *)malloc(strlen(value) + 1);
        strcpy(h->elem[pos], value);
        return 1;
    } else {
        recreate(h);
        insert(h, value);
        return 0;
    }
}

//重建哈希表
void recreate(HashTable *h) {
    char **temp_elem;
    temp_elem = (char **)malloc(sizeof(char *) * h->size);
    for (int i = 0; i < h->size; i++) {
        if (h->elem[i] != NULL) {
            temp_elem[i] = (char *)malloc(strlen(h->elem[i]) + 1);
            strcpy(temp_elem[i], h->elem[i]);
        } else {
            temp_elem[i] = NULL;
        }
    }
    //释放哈希表h原来elem的存储空间
    for (int i = 0; i < h->size; i++) {
        if (h->elem[i] != NULL) {
            free(h->elem[i]);
        }
    }
    free(h->elem);
    int copy_size = h->size;
    h->size = h->size * 2;
    h->elem = (char **)malloc(sizeof(char *)  * h->size);
    for (int i = 0; i < h->size; i++) {
        h->elem[i] = NULL;
    }
    //把原来哈希表里的关键字一一插回到新的哈希表里
    for (int i = 0; i < copy_size; i++) {
        if (temp_elem[i] != NULL) {
            insert(h, temp_elem[i]);
        }
    }
    for (int i = 0; i < copy_size; i++) {
        if (temp_elem[i] != NULL) {
            free(temp_elem[i]);
        }
    }
    free(temp_elem);
}

void clear(HashTable *h) {
    for (int i = 0; i < h->size; ++i) {
        if (h->elem[i] != NULL) {
            free(h->elem[i]);
        }
    }
    free(h->elem);
    free(h);
}

int main() {
    HashTable *hashtable = (HashTable*)malloc(sizeof(HashTable));
    init(hashtable);
    char buffer[1000];
    int n;
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        scanf("%s", buffer);
        int ans = insert(hashtable, buffer);
        if (ans == 0) {
            printf("recreate while insert!\n");
        } else if (ans == 1) {
            printf("insert success!\n");
        } else if (ans == 2) {
            printf("It already exists!\n");
        }
    }
    int temp_pos, temp_times;
    scanf("%s", buffer);
    if (search(hashtable, buffer, &temp_pos, &temp_times)) {
        printf("search success!\n");
    } else {
        printf("search failed!\n");
    }
    clear(hashtable);
    return 0;
}
```

### 查找算法

操作：

1. 查找：在查找表中查看某个特定的记录是否存在
2. 检索：查找某个特性记录的各种属性
3. 插入：将某个不存在的数据元素插入到查找表中
4. 删除：从查找表中删除某个特定元素

**如果堆查找表只进行前两种操作，则称这种查找表为静态查找表**，静态查找表建立以后，就不能再执行插入或删除操作，查找表也不再发生变化。

对应的，**如果对查找表还要执行后两种操作，则称这类查找表为动态查找表**。

**静态查找表查找方法：顺序查找、折半查找、分块查找**

**动态查找表查找方法：二叉平衡树、B-树、哈希表**

使用平均查找长度来衡量查找算法的性能

**顺序查找**：在线性表中进行的查找算法 O(n)

**二分查找**：在线性表中进行的查找算法 O(logn)

**三分查找**：解决凸性函数或者凹性函数求极值点的问题　O(logn)

三分查找过程：

1. 首先将区间[L, R]平均分成三部分：[L, m1]、[m1, m2]、[m2, R]

2. 计算三等分点m1和m2对应的函数值f(m1)和f(m2)

3. 比较f(m1)和f(m2)的大小

   如果f(m1) > f(m2)，则说明点T一定不在区间[m2, R]内，右边界R更新成m2

   如果f(m1) < f(m2)，则说明点T一定不在区间[L, m1]内，左边界L更新成m1

   如果f(m1) = f(m2)，则说明点T一定落在区间[m1, m2]内，也可以将这种情况归为上面的任意一种

4. 重复以上操作，不断缩小查找区间，直到在精度要求的范围内，左边界L等于右边界R，这时边界点(L, f(L))或者(R, f(R))即是极大值点T

（同理，求极小值，将第三步中大于小于号反过来即可）

三分查找每次比较后，都会将区间长度缩小到原来的2/3

```c
int find_max(int *data, int length) {
    int left = 0, right = length - 1, num = 0;
    while (right - left >= 2) {
        num++;
        int m1 = left + (right - left) / 3;
        int m2 = right - (right - left + 2) / 3;
        if (data[m1] < data[m2]) {
            right = m2;
        } else {
            left = m1 + 1;
        }
    }
    if (data[left] < data[right]) {
        printf("%d ", num);
        return left;
    }
}
```

**分块查找**：适用于线性表需要频繁的动态变化的情况

将一个线性表分成若干子表，在查找时，先确定目标元素所在的子表再在该子表中去查找它

分块查找也叫作**索引顺序查找**，在分块查找方法中，需要建立一个索引表，索引表中包含两类信息：关键字和指针，关键字指的是每个子表中最大的关键字，指针则表示该子表中第一个元素在整个表中的下标

第i个子表中最大的关键字小于第i + 1个子表中最小的关键字

在每一个子表中，元素的排列是随意的，只能通过顺序查找完成最后的查找

### 排序算法

根据排序过程中元素是否完全保存在内存中，可以将算法分为**内部排序**和**外部排序**

对于一个排序算法，如果任意两个元素ai和aj在排序前的线性表中满足条件i < j且ai = aj，在排序后ai仍在aj之前，则称这个排序算法为**稳定排序**，否则称这个算法为**不稳定排序**。

稳定排序：插入排序、冒泡排序、归并排序

不稳定排序：选择排序、快速排序、堆排序、希尔排序

排序算法的优劣与它是否稳定无关

对于一个线性表，同一个元素经过不同的排序算法可能落到不同的位置

堆排序、归并排序的运行时间上界和比较排序（不考虑希尔排序）的最坏情况下的运行时间下界是相等的，认为他们的排序效率高于比较排序

**插入排序**：将线性表分为已排序的前半部分和待排序的后半部分，从待排序部分选出第一个元素，插入到已排序部分的对应位置中，直到全部记录都插入到已排序部分中。　O(n^2)

```c
void insert_sort(int *data, int length) {
    for (int i = 0; i < length; i++) {
        for (int j = i - 1; j >= 0; j--) {
            if (data[j] > data[j + 1]) {
                swap(&data[j], &data[j + 1]);
            } else {
                break;
            }
        }
    }
    return ;
}
```

**冒泡排序**：假如待排序线性表的长度为n，从前往后两两比较相邻元素的关键字，若a(i - 1) > a(i)，则交换它们，直到线性表比较完成。每趟交换以后最后一个元素一定是最大的，不再参与下一趟交换。直到一趟比较内没有进行交换，算法结束。　O(n ^ 2)

```c
void bubble_sort(int *data, int length) {
    for (int i = 0; i < length - 1; i++) {
        int swapped = 0;
        for (int j = 0; j < length - i - 1; j++) {
            if (data[j] > data[j + 1]) {
                swap(&data[j], &data[j + 1]);
                swapped = 1;
            }
        }
        if (swapped == 0) {
            break;
        }
    }
    return ;
}
```

**归并排序**：若当前要排序的区间为a0...a(n - 1)，则首先让a0...a(n - 1) / 2和a(n - 1) / 2 + 1...a(n - 1)这两个区间内的元素有序，再将这两个区间合并成一个更大的有序区间，直到整个线性表都被排序完成。　O(n)

```c
void merge_sort(int *data, int l, int r) {
    if (l == r) {
        return ;
    }
    int mid = (l + r) / 2;
    merge_sort(data, l, mid);
    merge_sort(data, mid + 1, r);
    int temp [r - l + 1];
    int x = l, y = mid + 1, loc = 0;   //x, y分别表示两个区间当前待插入的元素下标，loc已排序区间目前待插入的下标
    while (x <= mid || y <= r) {
        //再循环内部，每次都要找到一个合适插到已排序部分最后的元素，而可选的元素只有左半部分当前待插入的元素和右半部分当前待插入的元素
        if (x <= mid && (y > r || data[x] <= data[y])) {
            //如果左半部分还有元素待插入，并且，要么右半部分已经没有元素待插入了，要么左半部分待插入的元素的关键字不比右半部分的大，那么将左半部分的元素插入temp中
            temp[loc] = data[x];
            x++;
        } else {
            temp[loc] = data[y];
            y++;
        }
        loc++;
    }
    for (int i = l; i <= r; i++) {
        data[i] = temp [i - l];
    }
}
```

**选择排序**：每趟从线性表的待排序区域选取关键字最小的元素，将其放在已排序区域的最后。

每趟可以让待排序区域的元素量减少一个，所以总共需要n - 1趟操作就可以将整个线性表排序完成。　O(n)

```c 
void sort(int *data, int length) {
    int temp;
    for (int i = 0; i < length - 1; i++) {
        temp = i;
        for (int j = i + 1; j < length; j++) {
            if (data[temp] > data[j]) {
                temp = j;
            }
        }
        if (i != temp) {
            swap(&data[i], &data[temp]);
        }
    }
}
```

**堆排序**：用堆来优化的选择排序就是堆排序　O(logn)

**快速排序**：每次从待排序区间选取一个元素作为基准记录，所有比基准记录小的元素都在基准记录的左边，而所有比基准记录大的元素都在基准记录的右边。之后分别对基准记录的左边和右边两个区间进行快速排序，直至将整个线性表排序完成。

**快速排序的时间复杂度不是稳定的，可以证明快速排序的平均时间复杂度为O(nlogn)，最坏情况为O(n ^ 2)**，可以通过选择基准记录来尽可能避免最坏情况的出现。

```c
void quick_sort(int *data, int left, int right) {
    if (left > right) {
        return ;
    }
    int pivot = data[left], low = left, high = right;
    //pivot为基准数，low从左边遍历区间的左标记，high从右边遍历的右标记
    while (low < high) {
        while (low < high && data[high] >= pivot) {
            high--;　　//不断往左查找直到找到一个值比pivot小的元素
        }
        data[low] = data[high];
        while (low < high && data[low] <= pivot) {
            low++;   //不断往右查找直到找到一个值比pivot大的元素
        }
        data[high] = data[low];
    }
    data[low] = pivot;
    quick_sort(data, left, low - 1);
    quick_sort(data, low + 1, right);
}
```

