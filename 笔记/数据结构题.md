## 数据结构题

#### 顺序表和链表

> 计蒜客

1. 顺序表的循环左移

   例：长度为８的顺序表（１，２，３，４，５，６，７，８），循环左移３位后的结果为（４，５，６，７，８，１，２，３）

   样例输入：

   ```
   8 3
   1 2 3 4 5 6 7 8
   ```

   样例输出：

   ```
   4 5 6 7 8 1 2 3
   ```

   ```c
   #include <stdio.h>
   
   #define ERROR 0
   #define OK 1
   
   typedef struct Vector {
       int size, length;
       int *data;
   } Vector;
   
   void init(Vector *vector, int size) {
       vector->size = size;
       vector->length = 0;
       vector->data = (int *)malloc(sizeof(int) * size);
   }
   
   void expand(Vector *vector) {
       int *old_data = vector->data;
       vector->size = vector->size * 2;
       vector->data = (int *)malloc(sizeof(int) * vector->size);
       for (int i = 0; i < vector->length; i++) {
           vector->data[i] = old_data[i];
       }
       free(old_data);
   }
   
   int insert(Vector *vector, int loc, int value) {
       if (loc < 0 || loc > vector->length) {
           return ERROR;
       }
       if (vector->length >= vector->size) {
           expand(vector);
       }
       for (int i = vector->length; i > loc; i--) {
           vector->data[i] = vector->data[i - 1];
       }
       vector->data[loc] = value;
       vector->length++;
       return OK;
   }
   
   void print(Vector *vector) {
       for (int i = 0; i < vector->length; i++) {
           if (i > 0) {
               printf(" ");
           }
           printf("%d", vector->data[i]);
       }
       printf("\n");
   }
   
   void clean(Vector *vector) {
       free(vector->data);
       free(vector);
   }
   
   int main() {
       Vector *a = (Vector *)malloc(sizeof(Vector));
       init(a, 100);
       int n, k;
       scanf("%d %d", &n, &k);
       int value[100] = {0};
       for (int i = 0; i < n; i++) {
           scanf("%d", &value[i]);
       }
       for (int i = 0; i < n - k; i++) {
           insert(a, i, value[k + i]);
       }
       for (int i = 0; i < k; i++) {
           insert(a, i + n - k, value[i]);
       }
       print(a);
       clean(a);
       return 0;
   }
   ```

2. 稀疏多项式

   Pn(x) = c1 * x^e1 + c2 * x^e2 + ... + cm * x^em

   其中em > ... > e2 > e1 >= 0

   要求：输入的第一行为整数m，表示多项式有m项，之后输入m行，每行有两个元素，分别表示多项式各项的系数c与次数e，最后一行为待求多项式的变量值x，输出多项式的计算结果

   样例输入：

   ```
   3
   1 2
   2 1
   1 0
   3
   ```

   样例输出：

   ```
   16
   ```

   ```c
   #include <stdio.h>
   #include <stdlib.h>
   #include <math.h>
   
   typedef struct {
       int c, e;
   } Data;
   
   typedef struct Vector {
       int size, length;
       Data *data;
   } Vector;
   
   void init(Vector *vector, int size) {
       vector->data = (Data *)malloc(sizeof(Data) * size);
       vector->size = size;
       vector->length = 0;
   }
   
   int expand(Vector *vector) {
       Data *p = (Data *)realloc(vector->data, sizeof(Data) * 2 * vector->size);
       if (p == NULL) return 0;
       vector->data = p;
       vector->size *= 2;
       return 1;
   }
   
   int insert(Vector *vector, Data value, int loc) {
       if (loc < 0 || loc > vector->length) return 0;
       if (vector->length == vector->size) {
           if (expand(vector) == 0) {
               return 0;
           }
       } 
       for (int i = vector->length; i > loc; i--) {
           vector->data[i] = vector->data[i - 1];
       }
       vector->data[loc] = value;
       vector->length += 1;
       return 1;
   }
   
   void output(Vector *vector, int x) {
       int P = 0;
       for (int i = 0; i < vector->length; i++) {
           P += vector->data[i].c * (int)pow(x, vector->data[i].e);
       }
       printf("%d\n", P);
   }
   
   void clear(Vector *vector) {
       free(vector->data);
       free(vector);
   }
   
   int main() {
       Vector *v = (Vector *)malloc(sizeof(Vector));
       int m, x;
       Data data;
       scanf("%d", &m);
       init(v, m);
       for (int i = 0; i < m; i++) {
           scanf("%d %d", &data.c, &data.e);
           insert(v, data, i);
       }
       scanf("%d", &x);
       output(v, x);
       clear(v);
       return 0;
   }
   ```

3. 有序集合的交运算

   假设以两个元素依次递增有序排序排列的线性表A和Bf分别表示两个集合（即同一表中的元素值各不相同），现要求另辟空间构成一个线性表C，其元素为Ａ和Ｂ中元素的交集，且表Ｃ中的元素值也依值递增有序排列。

   输入有四行，每两行描述一个线性表，第一行为线性表长度，第二行为线性表的各元素

   输出有两行，第一行为线性表Ｃ的元素个数，第二行为线性表Ｃ元素顺序输出结果，按从小到大的顺序输出，每两个整数之间有空格，最后一个整数后面没有空格。

   样例输入：

   ```
   5
   1 2 3 4 5
   4
   1 2 3 4
   ```

   样例输出：

   ```
   4
   1 2 3 4
   ```

   ```c
   #include <stdio.h>
   #include <stdlib.h>
   
   typedef struct Vector {
       int size, length;
       int *data;
   } Vector;
   
   void init(Vector *vector, int size) {
       vector->data = (int *)malloc(sizeof(int) * size);
       vector->size = size;
       vector->length = 0;
   }
   
   int expand(Vector *vector) {
       int *p = (int *)realloc(vector->data, sizeof(int) * 2 * vector->size);
       if ( p == NULL) return 0;
       vector->data = p;
       vector->size *= 2;
       return 1;
   }
   
   int insert(Vector *vector, int value, int loc) {
       if (loc < 0 || loc > vector->length) return 0;
       if (vector->length == vector->size) {
           if (expand(vector) == 0) {
               return 0;
           }
       }
       for (int i = vector->length; i > loc; i--) {
           vector->data[i] = vector->data[i - 1];
       }
       vector->data[loc] = value;
       vector->length += 1;
       return 1;
   }
   
   int search(Vector *vector, int value) {
       for (int i = 0; i < vector->length; i++) {
           if (vector->data[i] == value) {
               return i;
           }
       }
       return -1;
   }
   
   void output(Vector *vector) {
       printf("%d\n", vector->length);
       for (int i = 0; i < vector->length; i++) {
           printf("%d", vector->data[i]);
           if (i < vector->length - 1) {
               printf(" ");
           }
       }
   }
   
   void clear(Vector *vector) {
       free(vector->data);
       free(vector);
   }
   
   int main() {
       Vector *va = (Vector *)malloc(sizeof(Vector));
       Vector *vb = (Vector *)malloc(sizeof(Vector));
       Vector *vc = (Vector *)malloc(sizeof(Vector));
       int x, y, a_value, b_value, j = 0;
       scanf("%d", &x);
       init(va, x);
       for (int i = 0; i < x; i++) {
           scanf("%d" , &a_value);
           insert(va, a_value, i);
       }
       scanf("%d", &y);
       init(vb, y);
       for (int i = 0; i < y; i++) {
           scanf("%d", &b_value);
           if (search(va, b_value) != -1) {
               insert(vc, b_value, j++);
           }
       }
       output(vc);
       clear(vc);
       return 0;
   }
   ```

4. 哪位同学最优秀

   Ｎ份简历，每份简历都有一个对应的id，编号从1开始，依次从第一份简历到最后一份简历，boss会从简历里抽掉Ｍ份简历，每次他随机念一个数字numi，然后从第一份简历开始数，数到第numi份时，就会把对应的简历抽掉，接着念下一个数字。抽掉Ｍ份简历后，boss从剩余的简历中，取出最中间的一份简历，说这位同学最优秀，计算这份简历的id。

   第一行输入两个整数n和m，第二行输入m个整数numi，表示boss依次念出来的数字。保证n-m是奇数，输入的numi小于等于当前剩余的简历数量。

   输出为一行，输出boss认为最优秀的同学的简历的id。

   样例输入：

   ```
   7 2
   2 4
   ```

   样例输出：

   ```
   4
   ```

   ```c
   #include <stdio.h>
   #include <stdlib.h>
   
   typedef struct Vector {
       int size, length;
       int *data;
   } Vector;
   
   void init(Vector *vector, int size) {
       vector->data = (int *)malloc(sizeof(int) * size);
       vector->size = size;
       vector->length = 0;
   }
   
   int insert(Vector *vector, int value, int loc) {
       if (loc < 0 || loc > vector->length) return 0;
       if (vector->length == vector->size) return 0;
       for (int i = vector->length; i > loc; i--) {
           vector->data[i] = vector->data[i - 1];
       }
       vector->data[loc] = value;
       vector->length += 1;
       return 1;
   }
   
   int erase(Vector *vector, int loc) {
       if (loc < 0 || loc > vector->length) return 0;
       if (vector->length == 0) return 0;
       for (int i = loc + 1; i < vector->length; i++) {
           vector->data[i - 1] = vector->data[i];
       }
       vector->length -= 1;
       return 1;
   }
   
   void output(Vector *vector) {
       int mid = (0 + vector->length + 1) / 2 - 1;
       printf("%d\n", vector->data[mid]);
   }
   
   void clear(Vector *vector) {
       free(vector->data);
       free(vector);
   }
   
   int main() {
       Vector *v = (Vector *)malloc(sizeof(Vector));
       int n, m, num;
       scanf("%d %d", &n, &m);
       init(v, n);
       if ((n - m + 2) / 2 == 0) return -1;
       for (int i = 0; i < n; i++) {
           insert(v, i + 1, i);
       }
       for (int i = 0; i < m; i++) {
           scanf("%d", &num);
           erase(v, num - 1);
       }
       output(v);
       clear(v);
       return 0;
   }
   ```

5. 单链表的就地转置

   输入共有两行，第一行为线性表的长度n，第二行共有n个大写字母，为顺序输入的线性表的元素，每两个大写字母之间一个空格。

   输出只有一行逆置后的线性表元素的顺序输出，每两个大写字母之间一个空格，最后没有。

   样例输入：

   ```
   5
   A B C D E
   ```

   样例输出：

   ```
   E D C B A
   ```

   ```c
   #include <stdio.h>
   #include <stdlib.h>
   
   typedef struct Node {
       char data;
       struct Node *next;
   } Node, *LinkList;
   
   LinkList insert(LinkList head, Node *node, int index) {
       if (head == NULL) {
           if (index != 0) return head;
           head = node;
           return head;
       }
       if (index == 0) {
           node->next = head;
           head = node;
           return head;
       }
       Node *current_node = head;
       int count = 0;
       while (current_node->next != NULL && count < index - 1) {
           current_node = current_node->next;
           count++;
       }
       if (count == index - 1) {
           node->next = current_node->next;
           current_node->next = node;
       }
       return head;
   }
   
   void output(LinkList head) {
       if (head == NULL) return ;
       Node *current_node = head;
       while (current_node != NULL) {
           if (current_node->next != NULL) {
           	printf("%c ", current_node->data);
           } else if (current_node->next == NULL) {
               printf("%c", current_node->data);
           }
           current_node = current_node->next;
       }
       printf("\n");
   }
   
   LinkList reverse(LinkList head) {
       if (head == NULL) return head;
       Node *current_node, *next_node;
       current_node = head->next;
       head->next = NULL;
       while (current_node != NULL) {
           next_node = current_node->next;
           current_node->next = head;
           head = current_node;
           current_node = next_node;
       }
       return head;
   }
   
   void clear(LinkList head) {
       Node *current_node = head;
       while (current_node != NULL) {
           Node *delete_node = current_node;
           current_node = current_node->next;
           free(delete_node);
       }
   }
   
   int main() {
       LinkList l = NULL;
       int n;
       char word;
       scanf("%d", &n);
       for (int i = 0; i < n; i++) {
           scanf("\n");
           scanf("%c", &word);
           if (i != n - 1) scanf(" ");
           Node *node = (Node *)malloc(sizeof(Node));
           node->data = word;
           node->next = NULL;
           l = insert(l, node, i);
       }
       l = reverse(l);
       output(l);
       clear(l);
       return 0;
   }
   ```

6. **单向循环链表变双向**

   已知有一个单向循环链表，其每个结点中含三个域：prior，data和next，其中data域为数据域，next为指向后继结点的指针域，prior也为指针域，但它的值为空，试编写算法将此单向循环链表改为双向循环链表，即使prior成为指向前驱结点的指针域。

   输入有三行，第一行为该单向循环链表的长度n，第二行为该单向循环链表的各个元素ai，它们各不相同且都为数字，，第三行为一个数字m，表示链表中的一个元素值，要求输出时以该元素为起点反向输出整个双向链表。

   输出为一行完成双向链表后以反向顺序输出链表，每两个整数之间一个空格，最后没有。

   样例输入：

   ```
   5
   1 2 3 4 6
   1
   ```

   样例输出：

   ```
   1 6 4 3 2
   ```

   ```c
   #include <stdio.h>
   #include <stdlib.h>
   
   typedef struct Node {
       int data;
       struct Node *next, *prior;
   } Node, *Linklist;
   
   Linklist insert(Linklist head, Node *node, int index) {
       if (head == NULL) {
           if (index != 0) {
               return head;
           }
           head = node;
           head->next = head;
           return head;
       }
       if (index == 0) {
           node->next = head->next;
           head->next = node;
           return head;
       }
       Node *current_node = head->next;
       int count = 0;
       while (current_node != head && count < index - 1) {
           current_node = current_node->next;
           count++;
       }
       if (count == index - 1) {
           node->next = current_node->next;
           current_node->next = node;
       }
       if (node = head->next) {
           head = node;
       }
       return head;
   }
   
   Linklist build(Linklist head) {
       Node *p, *q;
       if (head == NULL) {
           return head;
       }
       p = head;
       q= head->next;
       do {
           q->prior = p;
           p = p->next;
           q = q->next;
       } while (q != head->next);
       return head;
   }
   
   void output(Linklist head, int m) {
       int length = 0;
       Node *p = head, *q;
       while (p->data != m) {
           p = p->next;
       }
       q = p;
       printf("%d", p->data);
       p = p->prior;
       while (p != q) {
           printf(" %d", p->data);
           p = p->prior;
       }
       printf("\n");
       return ;
   }
   
   void clear(Linklist head) {
       Node *p, *q;
       if (head == NULL) {
           return ;
       }
       p = head->next;
       head->next = NULL;
       while (p) {
           q = p->next;
           free(p);
           p = q;
       }
       return ;
   }
   
   int main() {
       Linklist l = NULL;
       int n, m;
       scanf("%d", &n);
       for (int i = 0; i < n; i++) {
           Node *node = (Node *)malloc(sizeof(Node));
           scanf("%d", &node->data);
           node->next = NULL;
           l = insert(l, node, i);
       }
       l = build(l);
       scanf("%d", &m);
       output(l, m);
       clear(l);
       return 0;
   }
   ```

> LEETCODE

1. 【19】Remove Nth Node From End of List

   从列表末尾删除第N个节点

   Given a linked list, remove the *n*-th node from the end of list and return its head.

   给定链接列表，从列表末尾删除第*n*个节点并返回其头部。

   **Example:**

   ```
   Given linked list: 1->2->3->4->5, and n = 2.
   After removing the second node from the end, the linked list becomes 1->2->3->5.
   ```

   **Note:**

   Given *n* will always be valid.

   给定*n*将始终有效。

   **Followup:**

   Could you do this in one pass? 

   ```c
   / **
   *单链表的定义
   *struct ListNode {
   *	int val;
   *	struct ListNode *next;
   *};
   * /
   
   struct ListNode* removeNthFromEnd(struct ListNode* head, int n) {
   	        
   } 
   ```

   ```c
   / **
   *单链表的定义
   *struct ListNode {
   *	int val;
   *	struct ListNode *next;
   *};
   * /
   
   struct ListNode* removeNthFromEnd(struct ListNode* head, int n) {
   	        
   } 
   ```

2. 【24】Swap Nodes in Pairs

   成对交换节点

   Given a linked list, swap every two adjacent nodes and return its head.

   给定链表，交换每两个相邻节点并返回其头部。

   **Example:**

   ```
   Given 1->2->3->4, you should return the list as 2->1->4->3.
   ```

   **Note:**

   - Your algorithm should use only constant extra space.
   - 您的算法应该只使用恒定的额外空间。
   - You may **not** modify the values in the list's nodes, only nodes itself may be changed.
   - 您可能**无法**修改列表节点中的值，只能更改节点本身。

   ```c
   /**
   *单链表的定义
   *struct ListNode {
   *	int val;
   *	struct ListNode *next;
   *};
   */
   
   struct ListNode* swapPairs(struct ListNode* head) {
       
   }
   ```

3. 【83】Remove Duplicates from Sorted List

   从排序列表中删除重复项

   Given a sorted linked list, delete all duplicates such that each element appear only *once*.

    给定已排序的链接列表，删除所有重复项，使每个元素只出现*一次*。

   **Example 1:**

   ```
   Input: 1->1->2
   Output: 1->2
   ```

   **Example 2:**

   ```
   Input: 1->1->2->3->3
   Output: 1->2->3
   ```

   ```c
   /**
   *单链表的定义
   *struct ListNode {
   *	int val;
   *	struct ListNode *next;
   *};
   */
   
   struct ListNode* deleteDuplicates(struct ListNode* head) {
       
   }
   ```

4. 【141】 Linked List Cycle

   Given a linked list, determine if it has a cycle in it.

   给定一个链表，确定它是否有一个循环。

   Follow up:
   Can you solve it without using extra space?

   ```c
   /**
   *单链表的定义
   *struct ListNode {
   *	int val;
   *	struct ListNode *next;
   *};
   */
   
   bool hasCycle(struct ListNode* head) {
       
   }
   ```

5. 【160】 Intersection of Two Linked Lists

   Write a program to find the node at which the intersection of two singly linked lists begins.

    编写程序以找到两个单链表开头的节点。

   For example, the following two linked lists:

   ```
   A:          a1 → a2
                      ↘
                        c1 → c2 → c3
                      ↗            
   B:     b1 → b2 → b3
   ```

   begin to intersect at node c1.

   **Notes:**

   - If the two linked lists have no intersection at all, return `null`.
   - 如果两个链接列表根本没有交集，则返回`null`。
   - The linked lists must retain their original structure after the function returns.
   - 函数返回后，链接列表必须保留其原始结构。
   - You may assume there are no cycles anywhere in the entire linked structure.
   - 您可以假设整个链接结构中没有任何循环。
   - Your code should preferably run in O(n) time and use only O(1) memory.
   - 您的代码最好在O（n）时间内运行，并且只使用O（1）内存。

   ```c
   /**
   *单链表的定义
   *struct ListNode {
   *	int val;
   *	struct ListNode *next;
   *};
   */
   
   struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB){
       
   }
   ```

6. 【202】Happy Number

   Write an algorithm to determine if a number is "happy".

   A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.

   幸福数字是由以下过程定义的数字：从任何正整数开始，将数字替换为其数字的平方和，并重复该过程，直到数字等于1（它将保留），或者循环在一个不包括1的循环中无休止地。这个过程以1结尾的那些数字是幸福的数字。

   **Example:** 

   ```
   Input: 19
   Output: true
   Explanation: 
   12 + 92 = 82
   82 + 22 = 68
   62 + 82 = 100
   12 + 02 + 02 = 1
   ```

   ```c
   bool isHappy(int n) {
       
   }
   ```

7. 【203】Remove Linked List Elements

   Remove all elements from a linked list of integers that have value **val**.

   从具有值**val**的整数的链接列表中删除所有元素。

   **Example:**

   ```
   Input:  1->2->6->3->4->5->6, val = 6
   Output: 1->2->3->4->5
   ```

   ```c
   /**
    * Definition for singly-linked list.
    * struct ListNode {
    *     int val;
    *     struct ListNode *next;
    * };
    */
    
   struct ListNode* removeElements(struct ListNode* head, int val) {
       
   }
   ```

8. 【206】 Reverse Linked List

   Reverse a singly linked list.

   反转单链表。

   **Example:**

   ```
   Input: 1->2->3->4->5->NULL
   Output: 5->4->3->2->1->NULL
   ```

   **Follow up:**

   A linked list can be reversed either iteratively or recursively. Could you implement both?

   链接列表可以反复或递归地反转。你能同时实施吗？

   ```c
   /**
    * Definition for singly-linked list.
    * struct ListNode {
    *     int val;
    *     struct ListNode *next;
    * };
    */
   
   struct ListNode* reverseList(struct ListNode* head) {
       
   }
   ```

9. 【234】Palindrome Linked List

   Given a singly linked list, determine if it is a palindrome.

   给出一个单链表，确定它是否是回文。

   **Example 1:**

   ```
   Input: 1->2
   Output: false
   ```

   **Example 2:**

   ```
   Input: 1->2->2->1
   Output: true
   ```

   **Follow up:**
   Could you do it in O(n) time and O(1) space?

   ```c
   /**
    * Definition for singly-linked list.
    * struct ListNode {
    *     int val;
    *     struct ListNode *next;
    * };
    */
    
    bool isPalindrome(struct ListNode* head) {
        
    }
   ```

10. 【237】Delete Node in a Linked List

    Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.

    编写一个函数来删除单链表中的节点（尾部除外），只允许访问该节点。

    Given linked list -- head = [4,5,1,9], which looks like following:

    ```
        4 -> 5 -> 1 -> 9
    ```

    **Example 1:**

    ```
    Input: head = [4,5,1,9], node = 5
    Output: [4,1,9]
    Explanation: You are given the second node with value 5, the linked list
                 should become 4 -> 1 -> 9 after calling your function.
    ```

    **Example 2:**

    ```
    Input: head = [4,5,1,9], node = 1
    Output: [4,5,9]
    Explanation: You are given the third node with value 1, the linked list
                 should become 4 -> 5 -> 9 after calling your function.
    ```

    **Note:**

    - The linked list will have at least two elements.
    - 链表至少有两个元素。
    - All of the nodes' values will be unique.
    - 所有节点的值都是唯一的。
    - The given node will not be the tail and it will always be a valid node of the linked list.
    - 给定节点不是尾部，它始终是链表的有效节点。
    - Do not return anything from your function.
    - 不要从你的功能中返回任何东西。

    ```c
    /**
     * Definition for singly-linked list.
     * struct ListNode {
     *     int val;
     *     struct ListNode *next;
     * };
     */
     
    void deleteNode(struct ListNode* node) {
        
    }
    ```

> 题库

1. 在一个具有n个结点的有序单链表中插入一个新结点并仍然保持有序的时间复杂度是（）

   > O(n)

2. 数组定义为”int a\[4][5];”, 引用”*(a+1)+2″表示（） 

   > a\[1][2]的地址，即a数组第2行第3列元素的地址

3. 关于 int a[10]; 问下面哪些不可以表示 a[1] 的地址？ 

   A. a+sizeof(int)       //相当于指针运算a + 4

   B. &a[0]+1　　//数组首元素地址加1，即a\[1]的地址

   C. (int*)&a+1         //数组地址被强制类型转换为int\*，然后加1，即a\[1]的地址

   D. (int\*)((char*)&a+sizeof(int))         //数组地址先被转换为char\*，加4，之后被转换为int\*，即a\[1]的地址

   > A

4. **带头结点**的单链表head为空的判定条件（ ）

   > head->next == NULL
   >
   > 不带头结点则为head == NULL

5. 采用二分查找的数据只适合采用顺序存储结构，不适用于链式存储结构。

   > 二分查找（折半查找）属于随机访问特性
   >
   > 堆排序也不能用链表 因为调整堆时没法随机访问底层孩子节点
   >
   > 快速排序可以链表
   >
   > 归并排序可用链表
   >
   > 基数排序可用链表
   >
   > 插入排序链表比数组要快一些 减少移动次数

6. 有种数据结构叫跳跃列表（Skip List），它是一种基于并联的链表的随机化数据结构，其效率可比拟于二叉查找树（对于大于数操作需要O(log n)平均时间）。它是按层建造的。底层是一个普通的有序链表。每个更高层都充当下面列表的“快速跑道”，这里在层i中的元素按概率l/p出现在层i+1中。平均起来，每个元素都在p/(p-1)个列表中出现，而最高层的元素（通常是在跳跃列表前段的一个特殊的头元素）在O(logp n)个列表中出现。调节p的大小可以在内存消耗和时间消耗上进行折中。试分析在该数据结构中查找一个元素的平均时间复杂度。

   > O(log n)（效率比拟于二叉排序树）

7. 若对n阶对称矩阵A(下标从1,1开始）以行序为主序方式将其下三角形的元素(包括主对角线上所有元素)依次存放于一维数组B[1…(n(n+1))/2]中,则在B中确定aij的位置k的关系为() 

   > i * (i - 1) / 2 + j

8. 用运算符sizeof 可以计算出数组的容量（字节数）　　　//sizeof(数组名)

   用运算符sizeof 可以计算出指针所指向内容的容量（字节数） (错，只是指针的容量)

   数组要么在静态存储区被创建（如全局数组），要么在栈上被创建　(错，动态存储区，堆上创建动态数组)

   指针可以随时指向任意类型的内存块　　(错，const指针不可以)

9. 结点除自身信息外还包括指针域，因此存储密度小于顺序存储结构

10. 对一个具有n个元素的线性表，建立其有序单链表的时间复杂度为（）

    > O(nlog2n)
    >
    > 应该是先排序，在构建链表，排序是O(nlogn)，构建链表是O(n) 
    >
    > 总的时间复杂度为O(nlogn)+O(n)=O(nlog2n)

11. 下列代码的输出为：  

    ```c++
    #include "iostream"  
    #include "vector"  
    using namespace std;  
       
    int main()  {  
        vector<int>array;  
        array.push_back(100);  
        array.push_back(300);  
        array.push_back(300);  
        array.push_back(500);  
        vector<int>::iterator itor;  
        for(itor = array.begin();itor != array.end();itor++)  {  
            if(*itor == 300) {  
                itor = array.erase(itor);    //erase返回下一项，删除第一个300后，返回第二个300，itor++后到500，第二个300被跳过
            }  
        }  
        for(itor = array.begin(); itor! = array.end() ;itor++) {  
            cout<< *itor << " ";  
        }  
        return 0;  
    }  
    ```

    > 100  300  500
    >
    > 遍历所有代码for循环中不执行itor++

12. 关于线性表中的链表描述正确的是（） 

    > 逻辑相邻的2元素的存储空间可以是不连续的。　　　//存储可以不连续，逻辑上连续
    >
    > 链表节点一般有数据元素和指针域两部分组成。
    >
    > 存储空间需要动态分配。
    >
    > 插入或删除时，无需移动其它元素。
    >
    > 对于单链表来说，只有指向链表头的头指针，所以不能随机访问表内元素，只能通过指针的移动。
    >
    > 链表的存储空间是不需要事先估计的，他不是线性的，所以可以随着结点的增加而随时增加存储空间。

13. 已知数组D的定义是int D\[4][8];,现在需要把这个数组作为实参传递给一个函数进行处理。下列说明汇总可以作为对应的形参变量说明的是（）。

    > int (*s)[8]
    >
    > int D\[][8]
    >
    > 错：int D\[4][]、int *s\[8]（表示有8个指向int指针的数组）
    >
    > 二维数组在内存中也是连续存储的，他可以通过 arr\[i][j]寻址是因为我们定义了这个数组有多少列，
    >
    > 加入有N列，这样数组寻址的时候编译器会自动得到 \*(arr+(j*N)+i)所以传参数的时候列数必须指定。
    >
    > (*s)等价于s[]

#### 队列和栈

1. 通话记录

   已知10条通话记录，0代表未接来电，1代表已接来电，2代表已拨电话，要求分别将三种类型前十条通话记录以三列的形式输出

   每列之间用一个空格分割，最后一列没有空格，每种类型输出前十个电话，先出现的通话记录先输出，不足十个的用0占位

   样例输入：

   ```
   2 18270477699
   1 10149800116
   0 19906559817
   1 16209018105
   1 16804212234
   2 19289130583
   1 17982711123
   0 10897630486
   1 11860787674
   0 15192777554
   ```

   样例输出：

   ```
   19906559817 10149800116 18270477699
   10897630486 16209018105 19289130583
   15192777554 16804212234 0
   0 17982711123 0
   0 11860787674 0
   0 0 0
   0 0 0
   0 0 0
   0 0 0
   0 0 0
   ```

   ```c
   #include <stdio.h>
   
   char phone_num[3][10][12] = {0};
   int ind[3] = {0};
   
   int main() {
       int x;
       for (int i = 0; i < 10; i++) {
           scanf("%d", &x);
           scanf("%s", phone_num[x][ind[x]++]);
       }
       for (int i = 0; i < 10; i++) {
           printf("%s", ind[0] ? (ind[0]--, phone_num[0][i]) : "0");
           for (int j = 1; j <= 2; j++) {
               printf(" %s", ind[j] ? (ind[j]--, phone_num[j][i]) : "0");
           }
           printf("\n");
       }
       return 0;
   }
   ```

2. N个数从1到N依次入栈，判断输入的序列是否可能是出栈序列

   样例输入：

   ```
   5
   2 1 5 4 3
   ```

   样例输出：

   ```
   YES
   ```

   ```c
   #include <stdio.h>
   #include <stdlib.h>
   
   typedef struct Stack {
       int *data;
       int size, top;
   } Stack;
   
   void init(Stack *s, int size) {
       s->data = (int *)malloc(sizeof(int) * size);
       s->size = size;
       s->top = -1;
   }
   
   int push(Stack *s, int x) {
       if (s->top >= s->size - 1) {
           return 0;
       }
       s->top++;
       s->data[s->top] = x;
       return 1;
   }
   
   int pop(Stack *s) {
       if (s->top < 0) {
           return 0;
       }
       s->top--;
       return 1;
   }
   
   int top(Stack *s) {
       return s->data[s->top];
   }
   
   int empty(Stack *s) {
       if (s->top < 0) {
           return 1;
       }
       return 0;
   } 
   
   void clear(Stack *s) {
       free(s->data);
       free(s);
   }
   
   int main() {
       int x, m, id = 0, flag = 1;
       scanf("%d", &x);
       Stack *s = (Stack *)malloc(sizeof(Stack));
       init(s, x);
       for (int i = 0; i < x; i++) {
           scanf("%d", &m);
           while (id < m) {
               id++;
               push(s, id);
           }
           if (empty(s) || top(s) != m) {
               flag = 0;
           }
           pop(s);
       }
       printf("%s\n", flag == 1 ? "YES" : "NO");
       clear(s);
       return 0;
   }
   ```

3. 表达式由数字和双目四则运算符+、-、*、/构成，试利用栈实现一个算法，将一个通常书写形式且书写正确的表达式**转换为逆波兰式（后缀表达式）**，同时将转换后的逆波兰式求值，**最后只输出求值结果**。

   输入共有一行，为待求值的表达式，**以换行结束**，表达式保证是合法的表达式中的整数在[1-10]内，表达式长度不超过20。

   样例输入：

   ```
   1+2+3+4+5
   ```

   样例输出：

   ```
   15
   ```

   ```c
   #include <stdio.h>
   #include <stdlib.h>
   #include <ctype.h>
   
   #define ERROR 0
   #define OK 1
   
   typedef struct Stack {
       char *data;
       int size, top;
   } Stack;
   
   void init(Stack *s, int size) {
       s->data = (char *)malloc(sizeof(char) * size);
       s->size = size;
       s->top = -1;
   }
   
   int push(Stack *s, char x) {
       if (s->top >= s->size - 1) {
           return ERROR;
       }
       s->top++;
       s->data[s->top] = x;
       return OK;
   }
   
   int pop(Stack *s) {
       if (s->top < 0) {
           return ERROR;
       }
       s->top--;
       return OK;
   }
   
   int top(Stack *s) {
       return s->data[s->top];
   }
   
   int empty(Stack *s) {
       if (s->top < 0) {
           return 1;
       }
       return 0;
   }
   
   void clear(Stack *s) {
       free(s->data);
       free(s);
   }
   
   int precede(char a, char b) {
       if ((a == '*' && b == '+') || (a == '*' && b == '-') || (a == '/' && b == '+') || (a == '/' && b == '-')) {
           return 1;
       }
       return 0;
   }
   
   int operate(char thata, int a, int b) {
       if (thata == '*') {
           return a * b;
       } else if (thata == '+') {
           return a + b;
       } else if (thata == '-') {
           return b - a;
       } else {
           return b / a;
       }
   }
   
   int main() {
       Stack *numbers = (Stack *)malloc(sizeof(Stack));
       init(numbers, 25);
       Stack *operators = (Stack *)malloc(sizeof(Stack));
       init(operators, 25);
       char a;
       while (scanf("%c", &a) != EOF) {
           if (isdigit(a)) {
               push(numbers, a);
           } else {
               if (empty(operators) || precede(a, top(operators))) {
                   push(operators, a);
               } else {
                   push(numbers, top(operators));
                   pop(operators);
                   while (!empty(operators)) {　　　　//只有加减乘除，只可能会剩下同级运算符
                       push(numbers, top(operators));
                       pop(operators);
                   }
                   push(operators, a);
               }
           }
       }
       while (!empty(operators)) {
           push(numbers, top(operators));
           pop(operators);
       }
       pop(numbers);　　　//换行符出栈
       while (!empty(numbers)) {
           push(operators, top(numbers));
           pop(numbers);
       }
       while (!empty(operators)) {
           if (top(operators) >= 48 && top(operators) <= 57) {
               push(numbers, top(operators));
               pop(operators);
           } else {
               int x = top(numbers) - '0';
               pop(numbers);
               int y = top(numbers) - '0';
               pop(numbers);
               push(numbers, operate(top(operators), x, y) + '0');
               pop(operators);
           }
       }
       printf("%d\n", top(numbers) - '0');
       clear(numbers);
       clear(operators);
       return 0;
   }
   ```

4. 判别读入的一个以@为结束符的字符是否是回文，是输出true，不是输出false。

   样例输入：

   ```
   abdcdba@
   ```

   样例输出：

   ```
   true
   ```

   ```c
   #include <stdio.h>
   #include <stdlib.h>
   
   #define ERROR 0
   #define OK 1
   
   typedef struct Stack {
       char *data;
       int size, top;
   } Stack;
   
   void init(Stack *s, int size) {
       s->data = (char *)malloc(sizeof(char) * size);
       s->size = size;
       s->top = -1;
   }
   
   int push(Stack *s, char x) {
       if (s->top >= s->size - 1) {
           return ERROR;
       }
       s->top++;
       s->data[s->top] = x;
       return OK;
   }
   
   int pop(Stack *s) {
       if (s->top < 0) {
           return ERROR;
       }
       s->top--;
       return OK;
   }
   
   int top(Stack *s) {
       return s->data[s->top];
   }
   
   int empty(Stack *s) {
       if (s->top < 0) {
           return 1;
       }
       return 0;
   }
   
   void clear(Stack *s) {
       free(s->data);
       free(s);
   }
   
   int main() {
       Stack *s = (Stack *)malloc(sizeof(Stack));
       init(s, 100);
       Stack *q = (Stack *)malloc(sizeof(Stack));
       init(q, 100);
       Stack *p = (Stack *)malloc(sizeof(Stack));
       init(p, 100);
       char a;
       while (scanf("%c", &a) != EOF) {
           push(s, a);
           push(q, a);
           push(p, a);
       }
       pop(s);
       while (!empty(s)) {
           push(q, top(s));
           pop(s);
       }
       push(q, '@');
       while (!empty(p) && !empty(q)) {
           if (top(p) != top(q)) {
               printf("false\n");
               return -1;
           }
           pop(p);
           pop(q);
       }
       printf("true\n");
       clear(s);
       clear(p);
       clear(q);
       return 0;
   }
   ```

> LEETCODE

1. 【20】Valid Parentheses

   Given a string containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.

   由于只包含字符的字符串`'('`，`')'`，`'{'`，`'}'`，`'['`和`']'`，确定输入字符串是有效的。

   An input string is valid if:

   如果输入字符串有效：

   1. Open brackets must be closed by the same type of brackets.(必须使用相同类型的括号关闭左括号。)
   2. Open brackets must be closed in the correct order.(必须以正确的顺序关闭左括号。)

   Note that an empty string is also considered valid.

   请注意，空字符串也被视为有效。

   **Example 1:**

   ```
   Input: "()"
   Output: true
   ```

   **Example 2:**

   ```
   Input: "()[]{}"
   Output: true
   ```

   **Example 3:**

   ```
   Input: "(]"
   Output: false
   ```

   **Example 4:**

   ```
   Input: "([)]"
   Output: false
   ```

   **Example 5:**

   ```
   Input: "{[]}"
   Output: true
   ```

   ```c
   bool isValid(char* s) {
       
   }
   ```

2. 【232】Implement Queue using Stacks

   Implement the following operations of a queue using stacks.

   使用堆栈实现队列的以下操作。

   - push(x) -- Push element x to the back of queue.
   - pop() -- Removes the element from in front of queue.
   - peek() -- Get the front element.
   - empty() -- Return whether the queue is empty.

   **Example:**

   ```
   MyQueue queue = new MyQueue();
   
   queue.push(1);
   queue.push(2);  
   queue.peek();  // returns 1
   queue.pop();   // returns 1
   queue.empty(); // returns false
   ```

   **Notes:**

   - You must use *only* standard operations of a stack -- which means only `push to top`, `peek/pop from top`, `size`, and `is empty` operations are valid.
   - 您必须使用*只有*一个堆栈的标准操作-这意味着只`push to top`，`peek/pop from top`，`size`，和`is empty`操作是有效的。

   - Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.
   - 根据您的语言，本机可能不支持堆栈。您可以使用列表或双端队列（双端队列）来模拟堆栈，只要您只使用堆栈的标准操作即可。

   - You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).
   - 您可以假设所有操作都是有效的（例如，不会在空队列上调用pop或Peek操作）。

   ```c
   typedef struct {
       
   } MyQueue;
   
   /** Initialize your data structure here. */
   MyQueue* myQueueCreate(int maxSize) {
       
   }
   
   /** Push element x to the back of queue. */
   void myQueuePush(MyQueue* obj, int x) {
       
   }
   
   /** Removes the element from in front of queue and returns that element. */
   int myQueuePop(MyQueue* obj) {
       
   }
   
   /** Get the front element. */
   int myQueuePeek(MyQueue* obj) {
       
   }
   
   /** Returns whether the queue is empty. */
   bool myQueueEmpty(MyQueue* obj) {
       
   }
   
   void myQueueFree(MyQueue* obj) {
       
   }
   
   /**
    * Your MyQueue struct will be instantiated and called as such:
    * struct MyQueue* obj = myQueueCreate(maxSize);
    * myQueuePush(obj, x);
    * int param_2 = myQueuePop(obj);
    * int param_3 = myQueuePeek(obj);
    * bool param_4 = myQueueEmpty(obj);
    * myQueueFree(obj);
    */
   ```

3. 【225】 Implement Stack using Queues

   lmplement the following operations of a stack using queues.

   使用队列实现堆栈的以下操作。

   - push(x) -- Push element x onto stack.
   - pop() -- Removes the element on top of the stack.
   - top() -- Get the top element.
   - empty() -- Return whether the stack is empty.

   **Example:**

   ```
   MyStack stack = new MyStack();
   
   stack.push(1);
   stack.push(2);  
   stack.top();   // returns 2
   stack.pop();   // returns 2
   stack.empty(); // returns false
   ```

   **Notes:**

   - You must use *only* standard operations of a queue -- which means only `push to back`, `peek/pop from front`, `size`, and `is empty` operations are valid.
   - 您必须使用*仅*一个队列的标准操作-这意味着只`push to back`，`peek/pop from front`，`size`，和`is empty`操作是有效的。
   - Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.
   - 根据您的语言，本机可能不支持队列。只要您只使用队列的标准操作，就可以使用list或deque（双端队列）来模拟队列。
   - You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).
   - 您可以假设所有操作都是有效的（例如，在空堆栈上不会调用pop或top操作）。

   ```c
   typedef struct {
       
   } MyStack;
   
   /** Initialize your data structure here. */
   MyStack* myStackCreate(int maxSize) {
       
   }
   
   /** Push element x onto stack. */
   void myStackPush(MyStack* obj, int x) {
       
   }
   
   /** Removes the element on top of the stack and returns that element. */
   int myStackPop(MyStack* obj) {
       
   }
   
   /** Get the top element. */
   int myStackTop(MyStack* obj) {
       
   }
   
   /** Returns whether the stack is empty. */
   bool myStackEmpty(MyStack* obj) {
       
   }
   
   void myStackFree(MyStack* obj) {
       
   }
   
   /**
    * Your MyStack struct will be instantiated and called as such:
    * struct MyStack* obj = myStackCreate(maxSize);
    * myStackPush(obj, x);
    * int param_2 = myStackPop(obj);
    * int param_3 = myStackTop(obj);
    * bool param_4 = myStackEmpty(obj);
    * myStackFree(obj);
    */
   ```

> 洛谷

1. 【1981】

   给定一个只包含加法和乘法的算术表达式，请你编程计算表达式的值。

   **输入格式：**

   一行，为需要你计算的表达式，表达式中只包含数字、加法运算符“++”和乘法运算符“\times×”，且没有括号，所有参与运算的数字均为 00 到 2^{31}-1231−1 之间的整数。

   输入数据保证这一行只有0-90−9、++、\times×这 1212种字符。

   **输出格式：**

   一个整数，表示这个表达式的值。

   注意：当答案长度多于 44 位时，请只输出最后44 位，前导00 不输出。

   **输入样例#1：**

   ```
   1+1*3+4
   ```

   **输出样例#1：**

   ```
   8
   ```

   **输入样例#2：**

   ```
   1+1234567890*1
   ```

   **输出样例#2：**

   ```
   7891
   ```

   **输入样例#3：**

   ```
   1+1000000003*1
   ```

   **输出样例#3：**

   ```
   4
   ```

   **说明**

   对于 30\%30%的数据，0≤0≤表达式中加法运算符和乘法运算符的总数≤100≤100；

   对于 80\%80%的数据，0≤0≤表达式中加法运算符和乘法运算符的总数≤1000≤1000；

   对于100\%100%的数据，0≤0≤表达式中加法运算符和乘法运算符的总数≤100000≤100000。

   ```c
   #include <stdio.h>
   #include <string.h>
   
   #define MAX_N 1300000
   #define MOD_NUM 10000
   #define INF 0x3f3f3f3f
   
   char str[MAX_N] = {0};
   
   int calc(char *str) {
       int len = strlen(str);
       for (int i = 0; str[i]; i++) str[i] = (str[i] == '+' ? 0 : str[i]);
       int total = 0;
       for (int j = 0; j < len; j += strlen(str + j) + 1) {
           int num = 0, p = 1;
           for (int i = j; str[i]; i++) {
               switch (str[i]) {
                   case '*' : p *= num; p %= MOD_NUM; num = 0; break;
                   default : num = num * 10 + str[i] - '0';
               }
           }
           p *= num;
           p %= MOD_NUM;
           total += p;
           total %= MOD_NUM;
       }
       return total;
   }
   
   int main() {
       scanf("%s", str);
       printf("%d\n", calc(str));
       return 0;
   }
   ```

2. 【1054】

   明明进了中学之后，学到了代数表达式。有一天，他碰到一个很麻烦的选择题。这个题目的题干中首先给出了一个代数表达式，然后列出了若干选项，每个选项也是一个代数表达式，题目的要求是判断选项中哪些代数表达式是和题干中的表达式等价的。

   这个题目手算很麻烦，因为明明对计算机编程很感兴趣，所以他想是不是可以用计算机来解决这个问题。假设你是明明，能完成这个任务吗？

   这个选择题中的每个表达式都满足下面的性质：

   1. 表达式只可能包含一个变量‘aa’。
   2. 表达式中出现的数都是正整数，而且都小于1000010000。
   3. 表达式中可以包括四种运算`+`（加），`-`（减），`*`（乘），`^`（乘幂），以及小括号`(`,`)`。小括号的优先级最高，其次是`^`，然后是`*`，最后是`+`和`-`。`+`和`-`的优先级是相同的。相同优先级的运算从左到右进行。（注意：运算符`+`，`-`，`*`，`^`以及小括号`(`，`)`都是英文字符）
   4. 幂指数只可能是11到1010之间的正整数（包括11和1010）。
   5. 表达式内部，头部或者尾部都可能有一些多余的空格。

   下面是一些合理的表达式的例子：

   `((a^1) ^ 2)^3`，`a*a+a-a`，`((a+a))`，`9999+(a-a)*a`，`1 + (a -1)^3`，`1^10^9`………

   **输入格式：**

   第一行给出的是题干中的表达式。

   第二行是一个整数n(2 \le n \le 26)n(2≤n≤26)，表示选项的个数。后面nn行，每行包括一个选项中的表达式。这nn个选项的标号分别是A,B,C,D…A,B,C,D…

   输入中的表达式的长度都不超过50个字符，而且保证选项中总有表达式和题干中的表达式是等价的。

   **输出格式：**

   一行，包括一系列选项的标号，表示哪些选项是和题干中的表达式等价的。选项的标号按照字母顺序排列，而且之间没有空格。

   **输入样例：**

   ```
   ( a + 1) ^2
   3
   (a-1)^2+4*a
   a + 1+ a
   a^2 + 2 * a * 1 + 1^2 + 10 -10 +a -a
   ```

   **输出样例：**

   ```
   AC
   ```

   **说明**

   对于30%的数据，表达式中只可能出现两种运算符‘+’和`-`；
   对于其它的数据，四种运算符`+`，`-`，`*`，`^`在表达式中都可能出现。
   对于全部的数据，表达式中都可能出现小括号`(`和`)`。

   ```c
   
   ```

> 题库

1. 

#### 树和二叉树

1. 神奇的二叉树

   输入第一行是一个字符串pre_str，代表原始二叉树的先序遍历结果，输入第二行是一个字符串in_str，代表二叉树的中序遍历结果。（两种结果构造出一棵唯一的二叉树）

   输出第一行，输出一个字符串，代表原始二叉树的后序遍历结果，输出第二行，输出一个字符串，代表镜子里的二叉树的后序遍历结果。

   样例输入：

   ```
   abdce
   dbaec
   ```

   样例输出：

   ```
   dbeca
   ecdba
   ```

   ```c
   #include <stdio.h>
   #include <stdlib.h>
   
   typedef struct Node {
       char data;
       struct Node *lchild, *rchild;
   } Node;
   
   Node *init(char data) {
       Node *node = (Node *)malloc(sizeof(Node));
       node->data = data;
       node->lchild = NULL;
       node->rchild = NULL;
       return node;
   }
   
   void postorder(Node *node) {
       if (node->lchild != NULL) {
           postorder(node->lchild);
       }
       if (node->rchild != NULL) {
           postorder(node->rchild);
       }
       printf("%c", node->data);
   }
   
   void opposite_postorder(Node *node) {
       if (node->rchild != NULL) {
           opposite_postorder(node->rchild);
       }
       if (node->lchild != NULL) {
           opposite_postorder(node->lchild);
       }
       printf("%c", node->data);
   }
   
   Node *build(char pre_str[], char in_str[], int len) {
       Node *p = init(pre_str[0]);
       int pos = strchr(in_str, pre_str[0]) - in_str;
       if (pos > 0) {
           p->lchild = build(pre_str + 1, in_str, pos);
       }
       if (len - pos - 1 > 0) {
           p->rchild = build(pre_str + pos + 1, in_str + pos + 1, len - pos - 1);
       }
       return p;                     
   }
   
   void clear(Node *node) {
       if (node->lchild != NULL) {
           clear(node->lchild);
       }
       if (node->rchild != NULL) {
           clear(node->rchild);
       }
       free(node);
   }
                             
   int main() {
       char pre_str[50], in_str[50];
       scanf("%s", &pre_str);
       scanf("%s", &in_str);
       Node *root = build(pre_str, in_str, strlen(pre_str));
       postorder(root);
       printf("\n");
       opposite_postorder(root);
       printf("\n");
       clear(root);
       return 0;
   }                          
   ```


> LEETCODE

1. 【100】Same Tree

   Given two binary trees, write a function to check if they are the same or not.

   Two binary trees are considered the same if they are structurally identical and the nodes have the same value.

   **Example 1:**

   ```
   Input:     1         1
             / \       / \
            2   3     2   3
   
           [1,2,3],   [1,2,3]
   
   Output: true
   ```

   **Example 2:**

   ```
   Input:     1         1
             /           \
            2             2
   
           [1,2],     [1,null,2]
   
   Output: false
   ```

   **Example 3:**

   ```
   Input:     1         1
             / \       / \
            2   1     1   2
   
           [1,2,1],   [1,1,2]
   
   Output: false
   ```

   ```c
   /**
    * Definition for a binary tree node.
    * struct TreeNode {
    *     int val;
    *     struct TreeNode *left;
    *     struct TreeNode *right;
    * };
    */
   bool isSameTree(struct TreeNode* p, struct TreeNode* q) {
       if (p == NULL && q == NULL) return true;
       if (p == NULL || q == NULL) return false;
       if (p->val != q->val) return false;
       return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
   }
   ```

2. 【101】Symmetric Tree

   Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).

   For example, this binary tree `[1,2,2,3,4,4,3]` is symmetric:

   ```
       1
      / \
     2   2
    / \ / \
   3  4 4  3
   ```

   But the following `[1,2,2,null,3,null,3]` is not:

   ```
       1
      / \
     2   2
      \   \
      3    3
   ```

   **Note:**
   Bonus points if you could solve it both recursively and iteratively.

   ```c
   /**
    * Definition for a binary tree node.
    * struct TreeNode {
    *     int val;
    *     struct TreeNode *left;
    *     struct TreeNode *right;
    * };
    */
   
   bool __isSymmetric(struct TreeNode *p, struct TreeNode *q) {
       if (p == NULL && q == NULL) return true;
       if (p == NULL || q == NULL) return false;
       if (p->val != q->val) return false;
       return __isSymmetric(p->left, q->right) && __isSymmetric(p->right, q->left);
   }
   
   bool isSymmetric(struct TreeNode* root) {
       if (root == NULL) return true;
       return __isSymmetric(root->left, root->right);
   }
   ```

3. 【102】Binary Tree Level Order Traversal

   Given a binary tree, return the *level order* traversal of its nodes' values. (ie, from left to right, level by level).

   For example:
   Given binary tree `[3,9,20,null,null,15,7]`,

   ```
       3
      / \
     9  20
       /  \
      15   7
   ```

   return its level order traversal as:

   ```
   [
     [3],
     [9,20],
     [15,7]
   ]
   ```

   ```c
   /**
    * Definition for a binary tree node.
    * struct TreeNode {
    *     int val;
    *     struct TreeNode *left;
    *     struct TreeNode *right;
    * };
    */
   /**
    * Return an array of arrays of size *returnSize.
    * The sizes of the arrays are returned as *columnSizes array.
    * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
    */
   
   int getHeight(struct TreeNode *root) {
       if (root == NULL) return 0;
       int l = getHeight(root->left), r = getHeight(root->right);
       return (l > r ? l : r) + 1;
   }
   
   void getColumns(struct TreeNode *root, int *cols, int k) {
       if (root == NULL) return ;
       cols[k] += 1;
       getColumns(root->left, cols, k + 1);
       getColumns(root->right, cols, k + 1);
       return ;
   }
   
   void getResult(struct TreeNode *root, int **ret, int *cols, int k) {
       if (root == NULL) return ;
       ret[k][cols[k]++] = root->val;
       getResult(root->left, ret, cols, k + 1);
       getResult(root->right, ret, cols, k + 1);
       return ;
   }
   
   int** levelOrder(struct TreeNode* root, int** columnSizes, int* returnSize) {
       *returnSize = getHeight(root);
       *columnSizes = (int *)calloc(sizeof(int), *returnSize);
       getColumns(root, *columnSizes, 0);
       int **ret = (int **)malloc(sizeof(int *) * (*returnSize));
       for (int i = 0; i < *returnSize; i++) {
           ret[i] = (int *)malloc(sizeof(int) * (*columnSizes)[i]);
           (*columnSizes)[i] = 0;
       }
       getResult(root, ret, *columnSizes, 0);
       return ret;
   }
   ```

4. 【107】Binary Tree Level Order Traversal II

   Given a binary tree, return the *bottom-up level order* traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).

   For example:
   Given binary tree `[3,9,20,null,null,15,7]`,

   ```
       3
      / \
     9  20
       /  \
      15   7
   ```

   return its bottom-up level order traversal as:

   ```
   [
     [15,7],
     [9,20],
     [3]
   ]
   ```

   ```c
   /**
    * Definition for a binary tree node.
    * struct TreeNode {
    *     int val;
    *     struct TreeNode *left;
    *     struct TreeNode *right;
    * };
    */
   /**
    * Return an array of arrays of size *returnSize.
    * The sizes of the arrays are returned as *columnSizes array.
    * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
    */
    
   int getHeight(struct TreeNode *root) {
       if (root == NULL) return 0;
       int l = getHeight(root->left), r = getHeight(root->right);
       return (l > r ? l : r) + 1;
   }
   
   void getColumns(struct TreeNode *root, int *cols, int k) {
       if (root == NULL) return ;
       cols[k] += 1;
       getColumns(root->left, cols, k - 1);
       getColumns(root->right, cols, k - 1);
       return ;
   }
   
   void getResult(struct TreeNode *root, int **ret, int *cols, int k) {
       if (root == NULL) return ;
       ret[k][cols[k]++] = root->val;
       getResult(root->left, ret, cols, k - 1);
       getResult(root->right, ret, cols, k - 1);
       return ;
   }
   
    int** levelOrderBottom(struct TreeNode* root, int** columnSizes, int* returnSize) {
        *returnSize = getHeight(root);
        *columnSizes = (int *)calloc(sizeof(int), *returnSize);
        getColumns(root, *columnSizes, *returnSize - 1);
        int **ret = (int **)malloc(sizeof(int *) * (*returnSize));
        for (int i = 0; i < *returnSize; i++) {
            ret[i] = (int *)malloc(sizeof(int) * (*columnSizes)[i]);
            (*columnSizes)[i] = 0;
        }
        getResult(root, ret, *columnSizes, *returnSize - 1);
        return ret;
    }
   ```

5. 【104】Maximum Depth of Binary Tree

   Given a binary tree, find its maximum depth.

   The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.

   **Note:** A leaf is a node with no children.

   **Example:**

   Given binary tree `[3,9,20,null,null,15,7]`,

   ```
       3
      / \
     9  20
       /  \
      15   7
   ```

   return its depth = 3.

   ```c
   /**
    * Definition for a binary tree node.
    * struct TreeNode {
    *     int val;
    *     struct TreeNode *left;
    *     struct TreeNode *right;
    * };
    */
   int maxDepth(struct TreeNode* root) {
       if (root == NULL) return 0;
       int l = maxDepth(root->left), r = maxDepth(root->right);
       return (l > r ? l : r) + 1;
   }
   ```

6. 【111】Minimum Depth of Binary Tree

   Given a binary tree, find its minimum depth.

   The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.

   **Note:** A leaf is a node with no children.

   **Example:**

   Given binary tree `[3,9,20,null,null,15,7]`,

   ```
       3
      / \
     9  20
       /  \
      15   7
   ```

   return its minimum depth = 2.

   ```c
   /**
    * Definition for a binary tree node.
    * struct TreeNode {
    *     int val;
    *     struct TreeNode *left;
    *     struct TreeNode *right;
    * };
    */
   int minDepth(struct TreeNode* root) {
       if (root == NULL) return 0;
       int l = minDepth(root->left), r = minDepth(root->rigth);
       if (root->left == NULL) return r + 1;
       if (root->right == NULL) return l + 1;
       return (l > r ? r : l) + 1;
   }
   ```

7. 【110】Balanced Binary Tree

   Given a binary tree, determine if it is height-balanced.

   For this problem, a height-balanced binary tree is defined as:

   > a binary tree in which the depth of the two subtrees of *every* node never differ by more than 1.

   **Example 1:**

   Given the following tree `[3,9,20,null,null,15,7]`:

   ```
       3
      / \
     9  20
       /  \
      15   7
   ```

   Return true.
   **Example 2:**

   Given the following tree `[1,2,2,3,3,null,null,4,4]`:

   ```
          1
         / \
        2   2
       / \
      3   3
     / \
    4   4
   ```

   Return false.

   ```c
   /**
    * Definition for a binary tree node.
    * struct TreeNode {
    *     int val;
    *     struct TreeNode *left;
    *     struct TreeNode *right;
    * };
    */
   
   int getHeight(struct TreeNode *root) {
       if (root == NULL) return 0;
       int l = getHeight(root->left);
       if (l < 0) return -2;    //l < 0左子树不平衡
       int r = getHeight(root->right);
       if (abs(l - r) > 1) return -2;
       return (l > r ? l : r) + 1;
   }
   
   bool isBalanced(struct TreeNode* root) {
       if (root == NULL) return true;
       return getHeight(root) > 0;
   }
   ```

8. 【112】Path Sum

   Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.

   **Note:** A leaf is a node with no children.

   **Example:**

   Given the below binary tree and `sum = 22`,

   ```
         5
        / \
       4   8
      /   / \
     11  13  4
    /  \      \
   7    2      1
   ```

   return true, as there exist a root-to-leaf path `5->4->11->2` which sum is 22.

   ```c
   /**
    * Definition for a binary tree node.
    * struct TreeNode {
    *     int val;
    *     struct TreeNode *left;
    *     struct TreeNode *right;
    * };
    */
   bool hasPathSum(struct TreeNode* root, int sum) {
       if (root == NULL) return false;
       if (root->left == NULL && root->right == NULL) return root->val == sum;
       return hasPathSum(root->left, sum - root->val) || hasPathSum(root->right, sum - root->val);
   }
   ```

9. 【226】Invert Binary Tree

   Invert a binary tree.

   **Example:**

   Input:

   ```
        4
      /   \
     2     7
    / \   / \
   1   3 6   9
   ```

   Output:

   ```
        4
      /   \
     7     2
    / \   / \
   9   6 3   1
   ```

   ```c
   /**
    * Definition for a binary tree node.
    * struct TreeNode {
    *     int val;
    *     struct TreeNode *left;
    *     struct TreeNode *right;
    * };
    */
   struct TreeNode* invertTree(struct TreeNode* root) {
       if (root == NULL) return root;
       struct TreeNode *Tree = root->left;
       root->left = root->right;
       root->right = Tree;
       invertTree(root->left);
       invertTree(root->right);
       return root;
   }
   ```

10. 【235】Lowest Common Ancestor of a Binary Search Tree

    Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.

    According to the [definition of LCA on Wikipedia](https://en.wikipedia.org/wiki/Lowest_common_ancestor): “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow **a node to be a descendant of itself**).”

    Given binary search tree:  root = [6,2,8,0,4,7,9,null,null,3,5]

    ```
            _______6______
           /              \
        ___2__          ___8__
       /      \        /      \
       0      _4       7       9
             /  \
             3   5
    ```

    **Example 1:**

    ```
    Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
    Output: 6
    Explanation: The LCA of nodes 2 and 8 is 6.
    ```

    **Example 2:**

    ```
    Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
    Output: 2
    Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself 
                 according to the LCA definition.
    ```

    **Note:**

    - All of the nodes' values will be unique.
    - p and q are different and both values will exist in the BST.

    ```c
    /**
     * Definition for a binary tree node.
     * struct TreeNode {
     *     int val;
     *     struct TreeNode *left;
     *     struct TreeNode *right;
     * };
     */
    
    int guang(struct TreeNode *root, struct TreeNode *p, struct TreeNode *q, struct TreeNode **result) {
        if (root == NULL) return 0;
        int ret = (root == p || root == q);
        ret += guang(root->left, p, q, result);
        if (ret == 2 && *result == NULL) *result = root;
        ret += guang(root->right, p, q, result);
        if (ret == 2 && *result == NULL) *result = root;
        return ret;
    }
    
    struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {
        struct TreeNode *result = NULL;
        guang(root, p, q, &result);
        return result;
    }
    ```

11. 【257】Binary Tree Paths

    Given a binary tree, return all root-to-leaf paths.

    **Note:** A leaf is a node with no children.

    **Example:**

    ```
    Input:
    
       1
     /   \
    2     3
     \
      5
    
    Output: ["1->2->5", "1->3"]
    
    Explanation: All root-to-leaf paths are: 1->2->5, 1->3
    ```

    ```c
    /**
     * Definition for a binary tree node.
     * struct TreeNode {
     *     int val;
     *     struct TreeNode *left;
     *     struct TreeNode *right;
     * };
     */
    /**
     * Return an array of size *returnSize.
     * Note: The returned array must be malloced, assume caller calls free().
     */
    
    char** binaryTreePaths(struct TreeNode* root, int* returnSize) {
        
    }
    ```

12. 【297】Serialize and Deserialize Binary Tree

    Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.

    Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.

    **Example:** 

    ```
    You may serialize the following tree:
    
        1
       / \
      2   3
         / \
        4   5
    
    as "[1,2,3,null,null,4,5]"
    ```

    **Clarification:** The above format is the same as [how LeetCode serializes a binary tree](https://leetcode.com/faq/#binary-tree). You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.

    **Note:** Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.

    ```c
    /**
     * Definition for a binary tree node.
     * struct TreeNode {
     *     int val;
     *     struct TreeNode *left;
     *     struct TreeNode *right;
     * };
     */
    
    /** Encodes a tree to a single string. */
    char* serialize(struct TreeNode* root) {
        
    }
    
    /** Decodes your encoded data to tree. */
    struct TreeNode* deserialize(char* data) {
        
    }
    
    // Your functions will be called as such:
    // char* data = serialize(root);
    // deserialize(data);
    ```


> 题库

#### 堆和优先队列

> 计蒜客

1. 将质量为a和b的小球合并成一个质量为(a * b ^ 2) ^(1/3)的小球

   输入第一行是一个正整数N，表示一共有N个小球，接下来输入N个正整数，表示每个小球的质量。每个小球的质量最大为1000.

   输出一行，输出合并最后，球的最小质量。最终结果和标准答案的误差在10^-3以内均认为正确。

   样例输入：

   ```
   5
   4 1 12 100 60
   ```

   样例输出：

   ```
   1.915696862302
   ```

   ```
   
   ```

   