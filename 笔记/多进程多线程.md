#### 多进程　共享内存

进程：一个正在执行的程序，每一个进程执行都有一个执行顺序，该顺序是一个执行路径，或者叫一个控制单元。

在操作系统中，一个进程是不能读写另一个进程的内存的，他们的进程内存必须是互相独立的，C语言把所有的设备都当作文件来处理，在内存里开辟了一段数据，开辟了一段缓冲区，把他模拟成设备，两个进程就能同时访问。

**共享内存**就是允许两个不相关的进程访问同一个逻辑内存，共享内存是在两个正在运行的进程之间共享和传递数据的一种非常有效的方式。不同进程之间共享的内存通常安排为同一段物理内存。进程可以将同一段共享内存连接到它们自己的地址空间中，所有进程都可以访问共享内存中的地址，就好像它们是由用C语言函数malloc分配的内存一样。而如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。

1. **创建共享内存**：

   ```
   int shmget(key_t key, size_t size, int shmflg);   
   ```

   key：非0整数，它有效地为共享内存段命名，shmget函数成功时返回一个与key相关的共享内存标识符（非负整数），用于后续的共享内存函数，调用失败返回-1。不相关的进程可以通过该函数的返回值访问同一共享内存，它代表程序可能要使用的某个资源，程序对所有共享内存的访问都是间接的，程序先通过调用shmget函数并提供一个键，再由系统生成一个相应的共享内存标识符（shmget函数的返回值），只有shmget函数才直接使用信号量键，所有其他的信号量函数使用由semget函数返回的信号量标识符。

   size：需要共享的内存容量

   shmflg：权限标志，与文件的读写权限一样，举例来说，0644，它表示允许一个进程创建的共享内存被内存创建者所拥有的进程向共享内存读取和写入数据，同时其他用户创建的进程只能读取共享内存。

2. 第一次创建完共享内存时，它还不能被任何进程访问，shmat函数的作用就是用来**启动对该共享内存的访问**，并把共享内存连接到当前进程的地址空间。

   ```c
   void *shmat(int shm_id, const voiod *shm_addr, int shmflg);
   ```

   shm_id：由shmget函数返回的共享内存标识

   shm_addr：指定共享内存连接到当前进程中的地址位置，通称为空，表示让系统来选择共享内存的地址

   shm_flg：一组标志位，通常为0

3. **将共享内存从当前进程中分离**。将共享内存分离并不是删除它，只是使该共享内存对当前进程不再可用。

   ```c 
   int shmctl(inr shm_id, int command, struct shmid_ds *buf);
   ```

   shm_id：由shmget函数返回的共享内存标识

   command：要采取的操作：

   1. IPC_STAT：把shmid_ds结构中的数据设置为共享内存的当前关联值，即用共享内存的当前关联值覆盖shmid_ds的值.
   2. IPC_SET：如果进程有足够的权限，就把共享内存的当前关联值设置为shmid_ds结构中给出的值
   3. IPC_RMID：删除共享内存段

    buf：结构指针，指向共享内存模式和访问权限的结构

   ```c
   struct shmid_ds { 
   
   	uid_t shm_perm.uid; 
   
   	uid_t shm_perm.gid; 
   
   	mode_t shm_perm.mode; 
   
   };
   ```



#### 多线程

线程：进程中的一个独立控制单元，线程在控制着进程的执行，进程是由若干线程组成的，一个进程至少有一个线程。多任务可以由多进程完成，也可以由一个进程内的多线程完成。

由于任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程。

多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。

线程和进程的区别在于,子进程和父进程有不同的代码和数据空间,而多个线程则共享数据空间,每个线程有自己的执行堆栈和程序计数器为其执行上下文.多线程主要是为了节约CPU时间,发挥利用,根据具体情况而定. 线程的运行中需要使用计算机的内存资源和CPU。

多线程的优点:

1. 能更好的利用CPU资源，如果只有一个线程，则第二个任务必须等到第一个热呢无结束后才能进行，如果使用多线程则在主线程执行任务的同时可以执行其他任务，而不需要等待；
2. 进程之间不能共享数据，线程可以；
3. 系统创建进程需要为该进程重新分配系统资源，创建线程代价比较小。

多线程的缺点:

1. 如果有大量的线程,会影响性能,因为操作系统需要在它们之间切换；
2. 更多的线程需要更多的内存空间；
3. 线程中止需要考虑对程序运行的影响；
4. 通常块模型数据是在多个线程间共享的,需要防止线程死锁情况的发生。

以下两个函数都包含在头文件pthread.h中

1. **创建一个新的线程**

   ```c
   int pthread_create(pthread_t *thread, pthread_attr_t *attr, void **func, void *arg);
   ```

   thread：指向pthread_t类型变量的指针

   attr：指向pthread_attr_t类型变量的指针，或者为NULL

​       func：指向新线程所运行函数的指针

​       arg：传递给func的参数

2. **等待某进程结束**：

   ```c
   int pthread_join(pthread_t thread, void **retval);
   ```

   thread：所等待的进程

   retval：指向某存储线程返回值的变量